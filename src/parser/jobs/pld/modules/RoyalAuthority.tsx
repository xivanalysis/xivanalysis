import {t} from '@lingui/macro'
import {Trans} from '@lingui/react'
import {DataLink} from 'components/ui/DbLink'
import {Events} from 'event'
import {Analyser} from 'parser/core/Analyser'
import {dependency} from 'parser/core/Injectable'
import Checklist, {TieredRule, TARGET, Requirement} from 'parser/core/modules/Checklist'
import {Data} from 'parser/core/modules/Data'
import React from 'react'

const SWORD_OATH_SEVERITY = {
	89: TARGET.WARN,
	94: TARGET.SUCCESS,
}

const DIVINE_MIGHT_SEVERITY = {
	89: TARGET.WARN,
	94: TARGET.SUCCESS,
}

interface SwordOath {
	initial: number
	stacks: number
	used: number
}

export class RoyalAuthority extends Analyser {
	static override handle = 'Royal Authority'
	static override title = t('pld.royal-authority.title')`Royal Authority`

	@dependency private checklist!: Checklist
	@dependency private data!: Data

	protected swordOathOvercap: number = 0

	private currentSwordOath: SwordOath | undefined
	private swordOathHistory: SwordOath[] = []

	private divineMightActive: boolean = false
	private divineMightUses: number = 0
	private divineMightTotal: number = 0

	override initialise() {

		this.addEventHook({
			type: 'action',
			source: this.parser.actor.id,
			action: this.data.actions.ATONEMENT.id,
		}, this.onAtonement)

		this.addEventHook({
			type: 'action',
			source: this.parser.actor.id,
			action: this.data.actions.HOLY_SPIRIT.id,
		}, this.onHolySpirit)

		this.addEventHook({
			type: 'action',
			source: this.parser.actor.id,
			action: this.data.actions.HOLY_CIRCLE.id,
		}, this.onHolyCircle)

		this.addEventHook({
			type: 'statusApply',
			target: this.parser.actor.id,
			status: this.data.statuses.SWORD_OATH.id,
		}, this.onApplySwordOath)

		this.addEventHook({
			type: 'statusRemove',
			target: this.parser.actor.id,
			status: this.data.statuses.SWORD_OATH.id,
		}, this.onRemoveSwordOath)

		this.addEventHook({
			type: 'statusApply',
			target: this.parser.actor.id,
			status: this.data.statuses.DIVINE_MIGHT.id,
		}, this.onApplyDivineMight)

		this.addEventHook({
			type: 'statusRemove',
			target: this.parser.actor.id,
			status: this.data.statuses.DIVINE_MIGHT.id,
		}, this.onRemoveDivineMight)

		this.addEventHook('complete', this.onComplete)
	}

	private onAtonement() {
		if (this.currentSwordOath == null) { return }
		this.currentSwordOath.used++
	}

	private onHolySpirit() {
		if (this.divineMightActive === false) { return }
		this.divineMightUses++
	}

	private onHolyCircle() {
		if (this.divineMightActive === false) { return }
		this.divineMightUses++
	}

	private onApplySwordOath(event: Events['statusApply']): void {
		if (event.data == null) { return }

		// Track potential uses & any overcap due to reapplication while the status was still active
		if (event.data === this.data.statuses.SWORD_OATH.stacksApplied) {
			if (this.currentSwordOath != null) {
				this.swordOathOvercap += this.currentSwordOath.stacks
				this.onRemoveSwordOath()
			}
		}

		if (this.currentSwordOath == null) {
			this.currentSwordOath = {
				initial: event.data,
				stacks: event.data,
				used: 0,
			}
		} else {
			this.currentSwordOath.stacks = event.data
		}
	}

	private onRemoveSwordOath(): void {
		if (this.currentSwordOath == null) { return }
		this.swordOathHistory.push(this.currentSwordOath)
		this.currentSwordOath = undefined
	}

	private onApplyDivineMight(): void {
		this.divineMightActive = true
		this.divineMightTotal++
	}

	private onRemoveDivineMight(): void {
		this.divineMightActive = false
	}

	private onComplete() {
		this.onRemoveSwordOath()
		this.onRemoveDivineMight()

		const swordOathStacks = this.data.statuses.SWORD_OATH.stacksApplied
		const swordOathStacksUsed = this.swordOathHistory.reduce((used, swordOath) => used + swordOath.used, 0)
		const swordOathPotentialStacks = this.swordOathHistory.reduce((potential, swordOath) => potential + swordOath.initial, 0)
		// Leaving the following commented out since it's not actually being used right now, but here's the calculation for checking dropped stacks if that data becomes useful
		// const droppedStacks = this.swordOathHistory.reduce((dropped, swordOath) => dropped + Math.max(swordOath.initial - swordOath.used, 0), 0)

		this.checklist.add(new TieredRule({
			name: <Trans id= "pld.sword-oath.checklist.name">Use Sword Oath stacks generated by Royal Authority</Trans>,
			description: <Trans id="pld.sword-oath.checklist.description">
				<DataLink action="ROYAL_AUTHORITY" /> generates {swordOathStacks} stacks of <DataLink status="SWORD_OATH" /> to use on <DataLink action="ATONEMENT" />.
				This is effectively the same as getting {swordOathStacks} uses of <DataLink showIcon={false} action="ROYAL_AUTHORITY" />.
			</Trans>,
			tiers: SWORD_OATH_SEVERITY,
			requirements: [
				new Requirement({
					name: <Trans id="pld.sword-oath.checklist.requirement.name">
						Uses of <DataLink status="SWORD_OATH" /> out of possible uses
					</Trans>,
					overrideDisplay: `${swordOathStacksUsed} / ${swordOathPotentialStacks} (${this.getPercent(swordOathStacksUsed, swordOathPotentialStacks).toFixed(2)}%)`,
					percent: this.getPercent(swordOathStacksUsed, swordOathPotentialStacks),
				}),
			],
		}))

		this.checklist.add(new TieredRule({
			name: <Trans id= "pld.divine-might.checklist.name">Use the Divine Might stack generated by Royal Authority</Trans>,
			description: <Trans id="pld.divine-might.checklist.description">
				<DataLink action="ROYAL_AUTHORITY" /> and <DataLink action="PROMINENCE" /> generate 1 stack of <DataLink status="DIVINE_MIGHT" /> to empower <DataLink action="HOLY_SPIRIT" /> or <DataLink action="HOLY_CIRCLE" />.
				This buffs the damage and removes the cast time for <DataLink action="HOLY_SPIRIT" /> and <DataLink action="HOLY_CIRCLE" />.
			</Trans>,
			tiers: DIVINE_MIGHT_SEVERITY,
			requirements: [
				new Requirement({
					name: <Trans id="pld.divine-might.checklist.requirement.name">
						Uses of <DataLink status="DIVINE_MIGHT" /> out of possible uses
					</Trans>,
					overrideDisplay: `${this.divineMightUses} / ${this.divineMightTotal} (${this.getPercent(this.divineMightUses, this.divineMightTotal).toFixed(2)}%)`,
					percent: this.getPercent(this.divineMightUses, this.divineMightTotal),
				}),
			],
		}))
	}

	private getPercent(actual: number, possible: number): number {
		return ((actual/possible) * 100)
	}

}
