import {t} from '@lingui/macro'
import {Trans} from '@lingui/react'
import {ActionLink} from 'components/ui/DbLink'
import {Analyser} from 'parser/core/Analyser'
import {dependency} from 'parser/core/Injectable'
import Checklist, {TieredRule, TARGET, Requirement} from 'parser/core/modules/Checklist'
import {Data} from 'parser/core/modules/Data'
import React from 'react'

// const STACKS_GAINED = 3

// In seconds
const USE_SEVERITY = {
	95: TARGET.WARN,
	100: TARGET.SUCCESS,
}

export default class Atonement extends Analyser {
	static override handle = 'Atonement'
	static override title = t('pld.Atonement.title')`Atonement`

	@dependency private checklist!: Checklist
	@dependency private data!: Data

	protected stacksUsed: number = 0
	protected stacksGained: number = 0

	override initialise() {

		this.addEventHook({
			type: 'action',
			source: this.parser.actor.id,
			action: this.data.actions.ATONEMENT.id,
		}, () => this.stacksUsed++)

		this.addEventHook({
			type: 'statusApply',
			target: this.parser.actor.id,
			status: this.data.statuses.SWORD_OATH.id,
		}, () => this.stacksGained = this.stacksGained++)

		this.addEventHook('complete', this.onComplete)
	}

	private onComplete() {

		this.checklist.add(new TieredRule({
			name: <Trans id= "pld.atonement.checklist.name"> Use Atonements Generated By Royal Authority </Trans>,
			description: <Trans id="pld.atonement.checklist.description">
				<ActionLink {...this.data.actions.ROYAL_AUTHORITY} /> generates 3 stacks of Sword Oath to use on <ActionLink {...this.data.actions.ATONEMENT} />,
				this is effectively the same as getting 3 <ActionLink {...this.data.actions.ROYAL_AUTHORITY} /> and you should make sure to use all stacks generated.
			</Trans>,
			tiers: USE_SEVERITY,
			requirements: [
				new Requirement({
					name: <Trans id="pld.atonement.checklist.requirement.atonement.name">
						Uses of <ActionLink {...this.data.actions.ATONEMENT} /> out of possible uses
					</Trans>,
					overrideDisplay: `${this.stacksUsed} / ${this.stacksGained} (${this.getPercent().toFixed(2)}%)`,
					percent: this.getPercent(),
				}),
			],
		}))
	}

	private getPercent() {
		const actual = this.stacksUsed
		const possible = this.stacksGained
		return ((actual/possible) * 100)
	}

}
