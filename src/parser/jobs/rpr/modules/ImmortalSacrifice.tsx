import {t} from '@lingui/macro'
import {Trans} from '@lingui/react'
import {DataLink} from 'components/ui/DbLink'
import {Event, Events} from 'event'
import {Analyser} from 'parser/core/Analyser'
import {filter} from 'parser/core/filter'
import {dependency} from 'parser/core/Injectable'
import BrokenLog from 'parser/core/modules/BrokenLog'
import Checklist, {Requirement, Rule} from 'parser/core/modules/Checklist'
import {Data} from 'parser/core/modules/Data'
import Suggestions, {SEVERITY, TieredSuggestion} from 'parser/core/modules/Suggestions'
import React from 'react'
import {matchClosestHigher} from 'utilities'
import {DISPLAY_ORDER} from './DISPLAY_ORDER'

interface ImmortalSacrificeWindow {
	stacks: number,
	consumed: boolean,
}

export class ImmortalSacrifice extends Analyser {
	static override debug = false
	static override handle = 'immortalSacrifice'
	static override title = t('rpr.immortalsacrifice.title')`Immortal Sacrifice`

	@dependency private brokenLog!: BrokenLog
	@dependency private data!: Data
	@dependency private checklist!: Checklist
	@dependency private suggestions!: Suggestions

	private history: ImmortalSacrificeWindow[] = []
	private current: ImmortalSacrificeWindow | undefined = undefined

	override initialise() {
		super.initialise()

		const playerFilter = filter<Event>().source(this.parser.actor.id)

		this.addEventHook(playerFilter.type('statusApply').status(this.data.statuses.IMMORTAL_SACRIFICE.id), this.onGain)
		this.addEventHook(playerFilter.type('statusRemove').status(this.data.statuses.IMMORTAL_SACRIFICE.id), this.onRemove)
		this.addEventHook(playerFilter.type('action').action(this.data.actions.PLENTIFUL_HARVEST.id), this.onHarvest)

		this.addEventHook('complete', this.onComplete)
	}

	private onGain(event: Events['statusApply']) {
		if (this.current == null) {
			this.current = {
				consumed: false,
				stacks: 0,
			}
		}

		this.current.stacks = event.data ?? this.current.stacks + 1
	}

	private onHarvest() {
		if (this.current == null) {
			this.brokenLog.trigger(this, 'rpr.immortalsacrifice.stacklessharvest',
				<Trans id="rpr.immortalsacrifice.stacklessharvest.reason">
					<DataLink action="PLENTIFUL_HARVEST"/> used without any <DataLink status="IMMORTAL_SACRIFICE"/> stacks.
				</Trans>)
			return
		}

		this.debug('Closing window because Plentiful Harvest was used', this.current)
		this.stopAndSave(true)
	}

	private onRemove() {
		// valid case, means it was consumed
		// event ordering can cause this to run first so this callback is more of a safety check
		if (this.current == null) {
			return
		}

		this.debug('Closing window that expired before consumption', this.current)
		this.stopAndSave(false)
	}

	private stopAndSave(consumed: boolean) {
		if (this.current == null) {
			return
		}

		this.current.consumed = consumed

		this.history.push(this.current)
		this.current = undefined
	}

	private onComplete() {
		// I hate this but it's more efficient than a bunch of reducers
		const harvestsTotal = this.history.length
		let harvestsConsumed = 0
		let stacksConsumed = 0
		let stacksTotal = 0

		for (const window of this.history) {
			stacksTotal += window.stacks

			if (window.consumed) {
				stacksConsumed += window.stacks
				harvestsConsumed += 1
			}
		}

		const harvestsConsumedPercent = this.getUsedPercent(harvestsConsumed, harvestsTotal)
		const stacksConsumedPercent = this.getUsedPercent(stacksConsumed, stacksTotal)

		this.checklist.add(new Rule({
			name: <Trans id="rpr.immortalsacrifice.checklist.title">
				Use Immortal Sacrifices with <DataLink action="PLENTIFUL_HARVEST"/>
			</Trans>,
			description: <Trans id="rpr.immortalsacrifice.checklist.description">
				<DataLink status="IMMORTAL_SACRIFICE"/> stacks are generated by using <DataLink action="ARCANE_CIRCLE"/> and consumed by <DataLink action="PLENTIFUL_HARVEST"/>.
				On top of having high damage, <DataLink showIcon={false} action="PLENTIFUL_HARVEST"/> also grants enough Shroud gauge to immediately use <DataLink action="ENSHROUD"/>.
			</Trans>,
			displayOrder: DISPLAY_ORDER.IMMORTAL_SACRIFICE,
			requirements: [
				new Requirement({
					name: <Trans id="rpr.immortalsacrifice.checklist.harvest.requirement.name">
						<DataLink action="PLENTIFUL_HARVEST"/> used %
					</Trans>,
					overrideDisplay: `${harvestsConsumed} / ${harvestsTotal} (${harvestsConsumedPercent}%)`,
					percent: harvestsConsumedPercent,
				}),

				new Requirement({
					name: <Trans id="rpr.immortalsacrifice.checklist.stacks.requirement.name">
						<DataLink status="IMMORTAL_SACRIFICE"/> stacks used %
					</Trans>,
					overrideDisplay: `${stacksConsumed} / ${stacksTotal} (${stacksConsumedPercent}%)`,
					percent: stacksConsumedPercent,
				}),
			],
		}))

		this.suggestions.add(new TieredSuggestion({
			icon: this.data.actions.ARCANE_CIRCLE.icon,
			content: <Trans id="rpr.immortalsacrifice.suggestion.unused.content">
				Try to generate stacks of <DataLink status="IMMORTAL_SACRIFICE"/> by using <DataLink action="ARCANE_CIRCLE"/> throughout the fight.
				<DataLink action="PLENTIFUL_HARVEST"/> is powerful but can't be used without any stacks of <DataLink showIcon={false} status="IMMORTAL_SACRIFICE"/>.
			</Trans>,
			matcher: matchClosestHigher,
			tiers: {
				0: SEVERITY.MAJOR,
			},
			value: stacksTotal,
			why: <Trans id="rpr.immortalsacrifice.suggestion.unused.why">
				No stacks of <DataLink status="IMMORTAL_SACRIFICE"/> were generated in this fight.
			</Trans>,
		}))
	}

	private getUsedPercent(used: number, total: number): string {
		return (used / total * 100).toFixed(2)
	}
}
