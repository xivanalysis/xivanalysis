import {Plural, Trans} from '@lingui/react'
import Color from 'color'
import {ActionLink} from 'components/ui/DbLink'
import ACTIONS from 'data/ACTIONS'
import JOBS from 'data/JOBS'
import STATUSES from 'data/STATUSES'
import {BuffEvent} from 'fflogs'
import _ from 'lodash'
import Module, {dependency} from 'parser/core/Module'
import Combatants from 'parser/core/modules/Combatants'
import {NormalisedDamageEvent} from 'parser/core/modules/NormalisedEvents'
import {ResourceDatum, ResourceGraphs} from 'parser/core/modules/ResourceGraphs'
import Suggestions, {SEVERITY, TieredSuggestion} from 'parser/core/modules/Suggestions'
import React from 'react'
import {FINISHES} from '../CommonData'

interface DancerResourceDatum extends ResourceDatum {
	isGenerator: boolean // Need to know if the resource event was a generator or a spender, used for graph smoothing
	t: number, // non-Epoch-based timestamp since I haven't figured out how to translate to/from that, needed for Technicalities
}

interface DancerGauge {
	currentAmount: number,
	overcapAmount: number,
	maximum: number,
	history: DancerResourceDatum[],
}

// More lenient than usual due to the probable unreliability of the data.
const GAUGE_SEVERITY_TIERS = {
	1: SEVERITY.MINOR,
	5: SEVERITY.MEDIUM,
	10: SEVERITY.MAJOR,
}

// Dances take more than a GCD to apply, during which time party members will be generating esprit for you
// We'll need to multiply the amount generated by the VERY rough-estimate of how many GCDs passed while you were dancing
const ESPRIT_GENERATION_MULTIPLIERS = {
	[ACTIONS.CASCADE.id]: 1,
	[ACTIONS.REVERSE_CASCADE.id]: 1,
	[ACTIONS.FOUNTAIN.id]: 1,
	[ACTIONS.FOUNTAINFALL.id]: 1,
	[ACTIONS.WINDMILL.id]: 1,
	[ACTIONS.RISING_WINDMILL.id]: 1,
	[ACTIONS.BLADESHOWER.id]: 1,
	[ACTIONS.BLOODSHOWER.id]: 1,
	[ACTIONS.SABER_DANCE.id]: 1,
	[ACTIONS.STANDARD_FINISH.id]: 2,
	[ACTIONS.SINGLE_STANDARD_FINISH.id]: 2,
	[ACTIONS.DOUBLE_STANDARD_FINISH.id]: 2,
	[ACTIONS.TECHNICAL_FINISH.id]: 3,
	[ACTIONS.SINGLE_TECHNICAL_FINISH.id]: 3,
	[ACTIONS.DOUBLE_TECHNICAL_FINISH.id]: 3,
	[ACTIONS.TRIPLE_TECHNICAL_FINISH.id]: 3,
	[ACTIONS.QUADRUPLE_TECHNICAL_FINISH.id]: 3,
}

const FEATHER_GENERATORS = [
	ACTIONS.REVERSE_CASCADE.id,
	ACTIONS.FOUNTAINFALL.id,
	ACTIONS.RISING_WINDMILL.id,
	ACTIONS.BLOODSHOWER.id,
]

const FEATHER_CONSUMERS = [
	ACTIONS.FAN_DANCE.id,
	ACTIONS.FAN_DANCE_II.id,
]

const ESPRIT_GENERATION_AMOUNT = 10

const TICK_FREQUENCY = 3000
const MAX_IMPROV_TICKS = 5

const ESPRIT_RATE_SELF = 0.3
const ESPRIT_RATE_PARTY = 0.2
const FEATHER_GENERATION_CHANCE = .5

const MAX_ESPRIT = 100
const SABER_DANCE_COST = 50
const MAX_FEATHERS = 4

const DNC_COLOR = Color(JOBS.DANCER.colour)
export default class Gauge extends Module {
	static handle = 'gauge'

	@dependency private combatants!: Combatants
	@dependency private suggestions!: Suggestions
	@dependency private resourceGraphs!: ResourceGraphs

	private espritGauge: DancerGauge = {
		currentAmount: 0,
		overcapAmount: 0,
		maximum: MAX_ESPRIT,
		history: [{t: 0, time: this.parser.pull.timestamp, current: 0, maximum: MAX_ESPRIT, isGenerator: false}],
	}
	private featherGauge: DancerGauge = {
		currentAmount: 0,
		overcapAmount: 0,
		maximum: MAX_FEATHERS,
		history: [{t: 0, time: this.parser.pull.timestamp, current: 0, maximum: MAX_FEATHERS, isGenerator: false}],
	}

	private improvisationStart = 0

	protected init() {
		this.addEventHook('normaliseddamage', {by: 'player'}, this.onDamage)
		this.addEventHook('applybuff', {by: 'player', abilityId: STATUSES.IMPROVISATION.id}, this.startImprov)
		this.addEventHook('removebuff', {by: 'player', abilityId: STATUSES.IMPROVISATION.id}, this.endImprov)
		this.addEventHook('cast', {by: 'player', abilityId: ACTIONS.SABER_DANCE.id}, this.onConsumeEsprit)

		this.addEventHook('normaliseddamage', {by: 'player', abilityId: FEATHER_GENERATORS}, this.onCastGenerator)
		this.addEventHook('cast', {by: 'player', abilityId: FEATHER_CONSUMERS}, this.onConsumeFeather)

		this.addEventHook('death', {to: 'player'}, this.onDeath)
		this.addEventHook('complete', this.onComplete)
	}

	/* Public functions */
	public feathersSpentInRange(start: number, end: number): number {
		if (start > end) {
			return -1
		}
		return this.featherGauge.history.filter(event => event.t >= start - this.parser.fight.start_time && event.t <= end - this.parser.fight.start_time && !event.isGenerator).length
	}

	/* Gauge Event Hooks */
	private onDamage(event: NormalisedDamageEvent) {
		if (!ESPRIT_GENERATION_MULTIPLIERS[event.ability.guid] || !event.hasSuccessfulHit) {
			return
		}

		let generatedAmt = 0
		if (this.combatants.selected.hasStatus({statusId: STATUSES.TECHNICAL_FINISH.id, sourceID: this.combatants.selected.guid})) {
			generatedAmt += ESPRIT_GENERATION_MULTIPLIERS[event.ability.guid] * ESPRIT_GENERATION_AMOUNT * ESPRIT_RATE_PARTY * (Object.keys(this.combatants.getEntities()).length-1)
			// Finishes aren't a weaponskill, so they don't generate esprit
			if (!FINISHES[event.ability.guid]) {
				generatedAmt += ESPRIT_GENERATION_MULTIPLIERS[event.ability.guid] * ESPRIT_GENERATION_AMOUNT * ESPRIT_RATE_SELF
			}
		} else if (this.combatants.selected.hasStatus(STATUSES.ESPRIT.id)) {
			generatedAmt += ESPRIT_GENERATION_MULTIPLIERS[event.ability.guid] * ESPRIT_GENERATION_AMOUNT * ESPRIT_RATE_SELF
			if (this.combatants.selected.hasStatus(STATUSES.CLOSED_POSITION.id)) {
				generatedAmt += ESPRIT_GENERATION_MULTIPLIERS[event.ability.guid] * ESPRIT_GENERATION_AMOUNT * ESPRIT_RATE_PARTY
			}
		}

		this.generateGauge(this.espritGauge, generatedAmt)
	}

	private startImprov(event: BuffEvent) {
		this.improvisationStart = event.timestamp
	}

	private endImprov(event: BuffEvent) {
		const diff = event.timestamp - this.improvisationStart

		// Ticks could occur at any point in the duration (server tick) - always give at least one tick so we don't under-guess
		const ticks = Math.min(Math.max(1, Math.floor(diff / TICK_FREQUENCY)), MAX_IMPROV_TICKS)

		// Choosing to assume in this case that everyone is in range so you get the maximum amount of Esprit per tic
		this.generateGauge(this.espritGauge, ticks * ESPRIT_GENERATION_AMOUNT)
	}

	private onConsumeEsprit() {
		this.spendGauge(this.espritGauge, SABER_DANCE_COST)
	}

	private onCastGenerator(event: NormalisedDamageEvent) {
		if (!event.hasSuccessfulHit) {
			return
		}
		this.generateGauge(this.featherGauge, FEATHER_GENERATION_CHANCE)
	}

	private onConsumeFeather() {
		this.spendGauge(this.featherGauge, 1)
	}

	private onDeath() {
		this.setGauge(this.espritGauge, 0)
		this.setGauge(this.featherGauge, 0)
	}

	/* Gauge Event Helpers */
	private generateGauge(gauge: DancerGauge, generatedAmount: number) {
		if (generatedAmount > 0) {
			this.setGauge(gauge, gauge.currentAmount + generatedAmount, true)
		}
	}

	private spendGauge(gauge: DancerGauge, spentAmount: number) {
		// If we spent gauge that we don't think we have right now, fix the history to show that we obviously did
		if (gauge.currentAmount < spentAmount) {
			this.correctGaugeHistory(gauge.history, spentAmount, gauge.currentAmount)
		}

		this.setGauge(gauge, gauge.currentAmount - spentAmount)
	}

	private setGauge(gauge: DancerGauge, newAmount: number, isGenerator: boolean = false) {
		gauge.currentAmount = _.clamp(newAmount, 0, gauge.maximum)
		gauge.overcapAmount += Math.max(0, newAmount - gauge.currentAmount)

		const t = this.parser.currentTimestamp - this.parser.fight.start_time
		gauge.history.push({t, time: this.parser.currentEpochTimestamp, current: gauge.currentAmount, isGenerator, maximum: gauge.maximum})
	}

	private correctGaugeHistory(historyObject: DancerResourceDatum[], spenderCost: number, currentGauge: number) {
		let lastGeneratorIndex = _.findLastIndex(historyObject, event => event.isGenerator)
		lastGeneratorIndex = lastGeneratorIndex === -1 ? 0 : lastGeneratorIndex // Deal with possibility we don't have a generation event yet

		const underrunAmount = Math.abs(currentGauge - spenderCost)
		for (let i = lastGeneratorIndex; i < historyObject.length; i++) {
			historyObject[i].current += underrunAmount
		}

		if (lastGeneratorIndex === 0) {
			return
		}

		const previousSpenderIndex = _.findLastIndex(historyObject.slice(0, lastGeneratorIndex), event => !event.isGenerator)
		const adjustmentPerEvent = underrunAmount / (lastGeneratorIndex - previousSpenderIndex)
		for (let i = previousSpenderIndex + 1; i < lastGeneratorIndex; i ++) {
			historyObject[i].current += adjustmentPerEvent * (i - previousSpenderIndex)
		}
	}

	/* Parse Completion and output */
	private onComplete() {
		this.resourceGraphs.addResource({
			label: <Trans id="dnc.gauge.resource.esprit">Esprit</Trans>,
			colour: DNC_COLOR,
			data: this.espritGauge.history,
		})

		this.resourceGraphs.addResource({
			label: <Trans id="dnc.gauge.resource.feathers">Feathers</Trans>,
			// eslint-disable-next-line @typescript-eslint/no-magic-numbers
			colour: DNC_COLOR.fade(0.6).toString(),
			data: this.featherGauge.history,
		})

		const missedSaberDances = Math.floor(this.espritGauge.overcapAmount/SABER_DANCE_COST)
		this.suggestions.add(new TieredSuggestion({
			icon: ACTIONS.SABER_DANCE.icon,
			content: <Trans id="dnc.esprit.suggestions.overcapped-esprit.content">
				You may have lost uses of <ActionLink {...ACTIONS.SABER_DANCE} /> due to overcapping your Esprit gauge. Make sure you use it, especially if your gauge is above 80.
			</Trans>,
			tiers: GAUGE_SEVERITY_TIERS,
			value: missedSaberDances,
			why: <Trans id="dnc.esprit.suggestions.overcapped-esprit.why">
				<Plural value={missedSaberDances} one="# Saber Dance" other="# Saber Dances"/> may have been missed.
			</Trans>,
		}))

		const featherOvercap = Math.floor(this.featherGauge.overcapAmount)
		this.suggestions.add(new TieredSuggestion({
			icon: ACTIONS.FAN_DANCE_III.icon,
			content: <Trans id="dnc.feather-gauge.suggestions.overcapped-feathers.content">
				You may have lost uses of your <ActionLink {...ACTIONS.FAN_DANCE} />s due to using one of your procs while already holding four feathers. Make sure to use a feather with <ActionLink showIcon={false} {...ACTIONS.FAN_DANCE} /> or <ActionLink showIcon={false} {...ACTIONS.FAN_DANCE_II} /> before using a proc to prevent overcapping.
			</Trans>,
			tiers: GAUGE_SEVERITY_TIERS,
			value: featherOvercap,
			why: <Trans id="dnc.feather-gauge.suggestions.overcapped-feathers.why">
				<Plural value={featherOvercap} one="# feather" other="# feathers"/> may have been lost.
			</Trans>,
		}))
	}
}
