import {Plural, Trans} from '@lingui/react'
import Color from 'color'
import {ActionLink} from 'components/ui/DbLink'
import ACTIONS from 'data/ACTIONS'
import JOBS from 'data/JOBS'
import STATUSES from 'data/STATUSES'
import {BuffEvent} from 'fflogs'
import _ from 'lodash'
import Module, {dependency} from 'parser/core/Module'
import Combatants from 'parser/core/modules/Combatants'
import {NormalisedDamageEvent} from 'parser/core/modules/NormalisedEvents'
import {ResourceDatum, ResourceGraphs} from 'parser/core/modules/ResourceGraphs'
import Suggestions, {SEVERITY, TieredSuggestion} from 'parser/core/modules/Suggestions'
import React from 'react'
import {FINISHES} from '../CommonData'

interface DancerResourceDatum extends ResourceDatum {
	isGenerator: boolean // Need to know if the resource event was a generator or a spender, used for graph smoothing
}

interface FeatherResourceDatum extends DancerResourceDatum {
	t: number, // non-Epoch-based timestamp since I haven't figured out how to translate to/from that, needed for Technicalities
}

// More lenient than usual due to the probable unreliability of the data.
const GAUGE_SEVERITY_TIERS = {
	1: SEVERITY.MINOR,
	5: SEVERITY.MEDIUM,
	10: SEVERITY.MAJOR,
}

// Dances take more than a GCD to apply, during which time party members will be generating esprit for you
// We'll need to multiply the amount generated by the VERY rough-estimate of how many GCDs passed while you were dancing
const ESPRIT_GENERATION_MULTIPLIERS = {
	[ACTIONS.CASCADE.id]: 1,
	[ACTIONS.REVERSE_CASCADE.id]: 1,
	[ACTIONS.FOUNTAIN.id]: 1,
	[ACTIONS.FOUNTAINFALL.id]: 1,
	[ACTIONS.WINDMILL.id]: 1,
	[ACTIONS.RISING_WINDMILL.id]: 1,
	[ACTIONS.BLADESHOWER.id]: 1,
	[ACTIONS.BLOODSHOWER.id]: 1,
	[ACTIONS.SABER_DANCE.id]: 1,
	[ACTIONS.STANDARD_FINISH.id]: 2,
	[ACTIONS.SINGLE_STANDARD_FINISH.id]: 2,
	[ACTIONS.DOUBLE_STANDARD_FINISH.id]: 2,
	[ACTIONS.TECHNICAL_FINISH.id]: 3,
	[ACTIONS.SINGLE_TECHNICAL_FINISH.id]: 3,
	[ACTIONS.DOUBLE_TECHNICAL_FINISH.id]: 3,
	[ACTIONS.TRIPLE_TECHNICAL_FINISH.id]: 3,
	[ACTIONS.QUADRUPLE_TECHNICAL_FINISH.id]: 3,
}

const FEATHER_GENERATORS = [
	ACTIONS.REVERSE_CASCADE.id,
	ACTIONS.FOUNTAINFALL.id,
	ACTIONS.RISING_WINDMILL.id,
	ACTIONS.BLOODSHOWER.id,
]

const FEATHER_CONSUMERS = [
	ACTIONS.FAN_DANCE.id,
	ACTIONS.FAN_DANCE_II.id,
]

const ESPRIT_GENERATION_AMOUNT = 10

const TICK_FREQUENCY = 3000
const MAX_IMPROV_TICKS = 5

const ESPRIT_RATE_SELF = 0.3
const ESPRIT_RATE_PARTY = 0.2
const FEATHER_GENERATION_CHANCE = .5

const MAX_ESPRIT = 100
const SABER_DANCE_COST = 50
const MAX_FEATHERS = 4

const DNC_COLOR = Color(JOBS.DANCER.colour)
export default class Gauge extends Module {
	static handle = 'gauge'

	@dependency private combatants!: Combatants
	@dependency private suggestions!: Suggestions
	@dependency private resourceGraphs!: ResourceGraphs

	private espritHistory: DancerResourceDatum[] = [{time: this.parser.pull.timestamp, current: 0, maximum: MAX_ESPRIT, isGenerator: false}]
	private featherHistory: FeatherResourceDatum[] = [{t: 0, time: this.parser.pull.timestamp, current: 0, maximum: MAX_FEATHERS, isGenerator: false}]
	private currentEsprit = 0
	private espritOvercap = 0
	private improvisationStart = 0
	private currentFeathers = 0
	private featherOvercap = 0

	protected init() {
		this.addEventHook('normaliseddamage', {by: 'player'}, this.onDamage)
		this.addEventHook('applybuff', {by: 'player', abilityId: STATUSES.IMPROVISATION.id}, this.startImprov)
		this.addEventHook('removebuff', {by: 'player', abilityId: STATUSES.IMPROVISATION.id}, this.endImprov)
		this.addEventHook('cast', {by: 'player', abilityId: ACTIONS.SABER_DANCE.id}, this.onConsumeEsprit)

		this.addEventHook('normaliseddamage', {by: 'player', abilityId: FEATHER_GENERATORS}, this.onCastGenerator)
		this.addEventHook('cast', {by: 'player', abilityId: FEATHER_CONSUMERS}, this.onConsumeFeather)

		this.addEventHook('death', {to: 'player'}, this.onDeath)
		this.addEventHook('complete', this.onComplete)
	}

	/* Public functions */
	public feathersSpentInRange(start: number, end: number): number {
		if (start > end) {
			return -1
		}
		return this.featherHistory.filter(event => event.t >= start - this.parser.fight.start_time && event.t <= end - this.parser.fight.start_time && !event.isGenerator).length
	}

	/* Gauge Event Hooks */
	private onDamage(event: NormalisedDamageEvent) {
		if (!ESPRIT_GENERATION_MULTIPLIERS[event.ability.guid] || !event.hasSuccessfulHit) {
			return
		}
		let generatedAmt = 0
		if (this.combatants.selected.hasStatus({statusId: STATUSES.TECHNICAL_FINISH.id, sourceID: this.combatants.selected.guid})) {
			generatedAmt += ESPRIT_GENERATION_MULTIPLIERS[event.ability.guid] * ESPRIT_GENERATION_AMOUNT * ESPRIT_RATE_PARTY * (Object.keys(this.combatants.getEntities()).length-1)
			// Finishes aren't a weaponskill, so they don't generate esprit
			if (!FINISHES[event.ability.guid]) {
				generatedAmt += ESPRIT_GENERATION_MULTIPLIERS[event.ability.guid] * ESPRIT_GENERATION_AMOUNT * ESPRIT_RATE_SELF
			}
		} else if (this.combatants.selected.hasStatus(STATUSES.ESPRIT.id)) {
			generatedAmt += ESPRIT_GENERATION_MULTIPLIERS[event.ability.guid] * ESPRIT_GENERATION_AMOUNT * ESPRIT_RATE_SELF
			if (this.combatants.selected.hasStatus(STATUSES.CLOSED_POSITION.id)) {
				generatedAmt += ESPRIT_GENERATION_MULTIPLIERS[event.ability.guid] * ESPRIT_GENERATION_AMOUNT * ESPRIT_RATE_PARTY
			}
		}
		if (generatedAmt > 0) {
			this.setEsprit(this.currentEsprit + generatedAmt, true)
		}
	}

	private startImprov(event: BuffEvent) {
		this.improvisationStart = event.timestamp
	}

	private endImprov(event: BuffEvent) {
		const diff = event.timestamp - this.improvisationStart

		// Ticks could occur at any point in the duration (server tick) - always give at least one tick so we don't under-guess
		const ticks = Math.min(Math.max(1, Math.floor(diff / TICK_FREQUENCY)), MAX_IMPROV_TICKS)

		// Choosing to assume in this case that everyone is in range so you get the maximum amount of Esprit per tic
		this.setEsprit(this.currentEsprit + ticks * ESPRIT_GENERATION_AMOUNT, true)
	}

	private onConsumeEsprit() {
		// If we're using more esprit than we think we have, go back to the previous spender event and add some
		// more esprit to the intervening generation events so the graph looks more correct
		if (this.currentEsprit < SABER_DANCE_COST) {
			this.correctEspritHistory()
		}

		this.setEsprit(this.currentEsprit - SABER_DANCE_COST)
	}

	private onCastGenerator(event: NormalisedDamageEvent) {
		if (!event.hasSuccessfulHit) {
			return
		}
		this.setFeather(this.currentFeathers + FEATHER_GENERATION_CHANCE, true)
	}

	private onConsumeFeather() {
		// If we consumed a feather when we think we don't have one, clearly we do, so update the history to reflect that
		if (this.currentFeathers < 1) {
			this.correctFeatherHistory()
		}

		this.setFeather(this.currentFeathers - 1)
	}

	private onDeath() {
		this.setEsprit(0)
		this.setFeather(0)
	}

	/* Gauge Event Helpers */
	private setEsprit(value: number, generatorEvent: boolean = false) {
		this.currentEsprit = _.clamp(value, 0, MAX_ESPRIT)
		this.espritOvercap += Math.max(0, value - this.currentEsprit)

		this.espritHistory.push({time: this.parser.currentEpochTimestamp, current: this.currentEsprit, isGenerator: generatorEvent, maximum: MAX_ESPRIT})
	}

	private correctEspritHistory() {
		const totalUnderRun = Math.abs(this.currentEsprit - SABER_DANCE_COST)

		const lastSpendIndex = _.findLastIndex(this.espritHistory, event => !event.isGenerator)
		const adjustmentPerEvent = totalUnderRun / (this.espritHistory.length - (lastSpendIndex + 1))
		for (let i = lastSpendIndex + 1; i < this.espritHistory.length; i ++) {
			this.espritHistory[i].current = this.espritHistory[i].current + adjustmentPerEvent * (i - lastSpendIndex)
		}
	}

	private setFeather(value: number, generationEvent: boolean = false) {
		this.currentFeathers = _.clamp(value, 0, MAX_FEATHERS)
		this.featherOvercap += Math.max(0, value - this.currentFeathers)

		const t = this.parser.currentTimestamp - this.parser.fight.start_time
		this.featherHistory.push({t, time: this.parser.currentEpochTimestamp, current: this.currentFeathers, isGenerator: generationEvent, maximum: MAX_FEATHERS})

	}

	private correctFeatherHistory() {
		// Add the underrun amount to all events back to the previous spender so the graph shows we had enough to spend
		let lastGeneratorIndex = _.findLastIndex(this.featherHistory, event => event.isGenerator)
		lastGeneratorIndex = lastGeneratorIndex === -1 ? 0 : lastGeneratorIndex
		const underrun = 1 - this.currentFeathers
		for (let i = lastGeneratorIndex; i < this.featherHistory.length; i++) {
			this.featherHistory[i].current += underrun
		}

		// If there's nothing before the last generator, we don't need to smooth anything
		if (lastGeneratorIndex === 0) {
			return
		}

		// Find the last spender event prior to the generator event found above and linearly smooth the graph between the two events
		const prevSpenderIndex = _.findLastIndex(this.featherHistory.slice(0, lastGeneratorIndex), event => !event.isGenerator)
		const adjustmentPerEvent = underrun / (lastGeneratorIndex - prevSpenderIndex)
		for (let j = prevSpenderIndex + 1; j < lastGeneratorIndex; j ++) {
			this.featherHistory[j].current = this.featherHistory[j].current + adjustmentPerEvent * (j - prevSpenderIndex)
		}
	}

	private onComplete() {
		this.resourceGraphs.addResource({
			label: 'Esprit',
			colour: DNC_COLOR,
			data: this.espritHistory,
		})

		this.resourceGraphs.addResource({
			label: 'Feathers',
			colour: DNC_COLOR,
			data: this.featherHistory,
		})

		const missedSaberDances = Math.floor(this.espritOvercap/SABER_DANCE_COST)
		this.suggestions.add(new TieredSuggestion({
			icon: ACTIONS.SABER_DANCE.icon,
			content: <Trans id="dnc.esprit.suggestions.overcapped-esprit.content">
				You may have lost uses of <ActionLink {...ACTIONS.SABER_DANCE} /> due to overcapping your Esprit gauge. Make sure you use it, especially if your gauge is above 80.
			</Trans>,
			tiers: GAUGE_SEVERITY_TIERS,
			value: missedSaberDances,
			why: <Trans id="dnc.esprit.suggestions.overcapped-esprit.why">
				<Plural value={missedSaberDances} one="# Saber Dance" other="# Saber Dances"/> may have been missed.
			</Trans>,
		}))

		this.featherOvercap = Math.floor(this.featherOvercap)
		this.suggestions.add(new TieredSuggestion({
			icon: ACTIONS.FAN_DANCE_III.icon,
			content: <Trans id="dnc.feather-gauge.suggestions.overcapped-feathers.content">
				You may have lost uses of your <ActionLink {...ACTIONS.FAN_DANCE} />s due to using one of your procs while already holding four feathers. Make sure to use a feather with <ActionLink showIcon={false} {...ACTIONS.FAN_DANCE} /> or <ActionLink showIcon={false} {...ACTIONS.FAN_DANCE_II} /> before using a proc to prevent overcapping.
			</Trans>,
			tiers: GAUGE_SEVERITY_TIERS,
			value: this.featherOvercap,
			why: <Trans id="dnc.feather-gauge.suggestions.overcapped-feathers.why">
				<Plural value={this.featherOvercap} one="# feather" other="# feathers"/> may have been lost.
			</Trans>,
		}))
	}
}
