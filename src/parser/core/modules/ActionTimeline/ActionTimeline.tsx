import {Trans} from '@lingui/react'
import {Action, ActionKey} from 'data/ACTIONS'
import {Analyser} from 'parser/core/Analyser'
import {dependency} from 'parser/core/Injectable'
import CastTime from 'parser/core/modules/CastTime'
import {ChargeHistoryEntry, CooldownEndReason, CooldownGroup, CooldownHistoryEntry, Cooldowns, SelectionSpecifier} from 'parser/core/modules/Cooldowns'
import {Data} from 'parser/core/modules/Data'
import {ActionItem, BaseItem, ContainerRow, SimpleItem, Timeline} from 'parser/core/modules/Timeline'
import React, {ReactNode} from 'react'
import {Icon} from 'semantic-ui-react'
import {ensureArray, isDefined} from 'utilities'
import styles from './ActionTimeline.module.css'

const ANIMATION_LOCK = 100

// We're excluding the Action interface as it's unessecary for this config format, and complicates the discrimination later.
type RowSpecifierEntry = Exclude<SelectionSpecifier, Action>

/**
 * One or more actions, action keys, or cooldown group IDs. The special-case
 * value "GCD" is available for selection of the GCD cooldown group.
 */
export type RowSpecifier = RowSpecifierEntry | RowSpecifierEntry[]

/** Advanced configuration options for a row. */
export interface ActionRowConfig {
	/** Specifier(s) for items that should be displayed in this row. */
	content: RowSpecifier
	/** Label to display for the row. */
	label?: ReactNode
	/** Order of the row within the timeline. */
	order?: number
}

/** Configuration for a single row. */
export type ActionRow = RowSpecifier | ActionRowConfig

// Internal row config used within the module
type InternalRowConfig =
	& Omit<ActionRowConfig, 'content'>
	& {content: readonly SelectionSpecifier[]}

enum ItemDepth {
	CHARGE_GAIN = 0,
	ACTION = 1,
}

export class ActionTimeline extends Analyser {
	static override handle = 'actionTimeline'
	static override debug = false

	/**
	 * Configuration for the rows generated by this module. Any cooldown groups
	 * not represented in this configuration will be added to automatically
	 * generated rows in order of use.
	 */
	static rows: ActionRow[] = [
		{content: 'GCD', order: -97},
	]

	@dependency private castTime!: CastTime
	@dependency private cooldowns!: Cooldowns
	@dependency private data!: Data
	@dependency private timeline!: Timeline

	private resolvedRows: InternalRowConfig[] = []
	private groupRows = new Map<CooldownGroup, ContainerRow>()

	/** Retrieve the timeline row representing the specified action. */
	getRow(action: ActionKey | Action) {
		return this.addRow({content: [action]})
	}

	override initialise() {
		// Add rows for all the configured entries
		for (const config of (this.constructor as typeof ActionTimeline).rows) {
			const resolvedConfig = this.resolveConfig(config)
			this.resolvedRows.push(resolvedConfig)
			this.addRow(resolvedConfig)
		}

		this.addEventHook('complete', this.onComplete)
	}

	private onComplete() {
		// Track the groups with configured rows so backfill doesn't duplicate
		const populatedGroups = new Set<number>()

		// Add rows for all the configured entries
		for (const config of this.resolvedRows) {
			const row = this.addRow(config)
			this.populateRow(row, config)
			config.content.forEach(specifier =>
				this.cooldowns.groups(specifier).forEach(group => populatedGroups.add(group))
			)
		}

		// Figure out what groups have not been explicitly configured and build rows for them
		this.cooldowns.allGroups()
			.filter(group => !populatedGroups.has(group))
			.forEach(group => {
				const config = {content: [group]}
				const row = this.addRow(config)
				this.populateRow(row, config)
			})
	}

	private resolveConfig(config: ActionRow): InternalRowConfig {
		// Standardise the simple config into the main config shape
		let finalConfig = config
		if (typeof finalConfig !== 'object' || Array.isArray(finalConfig)) {
			finalConfig = {content: finalConfig}
		}
		return {
			...finalConfig,
			content: ensureArray(finalConfig.content),
		}
	}

	private addRow(config: InternalRowConfig) {
		// If there's already a row for one of the specifiers, use it
		const groups = config.content.flatMap(specifier => this.cooldowns.groups(specifier))
		const existingRow = groups
			.map(group => this.groupRows.get(group))
			.find(isDefined)
		if (existingRow != null) {
			return existingRow
		}

		// Using an IIFE because pattern matching isn't in the spec yet
		const firstContent = config.content[0]
		const label = (() => {
			if (config.label != null) { return config.label }
			if (firstContent === 'GCD')  { return <Trans id="core.action-timeline.label.gcd">GCD</Trans> }
			if (typeof firstContent === 'string') { return this.data.actions[firstContent].name }
			if (typeof firstContent === 'number') { return this.cooldowns.cooldownHistory(firstContent)[0]?.action.name }
			return firstContent.name
		})()

		// Build the row and save it to the groups for this config
		// TODO: collision handling?
		const row = this.timeline.addRow(new ContainerRow({
			label,
			order: config.order,
			collapse: true,
		}))
		groups.forEach(group => this.groupRows.set(group, row))

		return row
	}

	private populateRow(row: ContainerRow, {content}: InternalRowConfig) {
		// Add all the items
		this.addCooldownItems(row, content.flatMap(specifier => this.cooldowns.cooldownHistory(specifier)))
		this.addChargeItems(row, content.flatMap(specifier => this.cooldowns.chargeHistory(specifier)))
	}

	private addCooldownItems(row: ContainerRow, history: CooldownHistoryEntry[]) {
		for (const entry of history) {
			const duration = this.getCooldownDuration(entry)

			// TODO: with the adjusted cast time we might get some overlaps, should we try to avoid that?]
			// TODO: Add interrupt visuals. CD2 only records interrupts within the bounds of a cooldown, so we'll need to track it in some manner for long-cast actions.
			const start = entry.start - this.parser.pull.timestamp
			const end = start + duration
			row.addItem(new SimpleItem({
				start,
				end,
				content: <div className={styles.cooldown}/>,
			}))
		}
	}

	private addChargeItems(row: ContainerRow, history: ChargeHistoryEntry[]) {
		for (const entry of history) {
			const item = entry.delta < 0
				? new ActionItem({
					depth: ItemDepth.ACTION,
					start: entry.timestamp - this.parser.pull.timestamp,
					action: entry.action,
				})
				: new ChargeGainItem({
					depth: ItemDepth.CHARGE_GAIN,
					start: entry.timestamp - this.parser.pull.timestamp,
				})
			row.addItem(item)
		}
	}

	private getCooldownDuration(entry: CooldownHistoryEntry) {
		let duration = entry.end - entry.start

		// If the cooldown expired naturally, it _may_ have a cast time greater than its cooldown.
		if (entry.endReason === CooldownEndReason.EXPIRED) {
			const castTime = this.castTime.forAction(entry.action.id, entry.start) ?? 0

			// We add the animation lock constant to the cast time to mimic the game's
			// behaviour - also sometimes known as "caster tax".
			duration = Math.max(duration, castTime + ANIMATION_LOCK)
		}

		return duration
	}
}

class ChargeGainItem extends BaseItem {
	Content = () => (
		<div className={styles.chargeGain}>
			<Icon name="angle double up" className={styles.icon}/>
		</div>
	)
}
