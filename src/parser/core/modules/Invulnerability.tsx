import {Event, Events, Resource} from 'event'
import React from 'react'
import {Actor, ReportMetaKey, Team} from 'report'
import * as TB from 'ts-toolbelt'
import {Analyser} from '../Analyser'
import {exists, filter, oneOf} from '../filter'
import {dependency} from '../Injectable'
import {SimpleItem, SimpleRow, Timeline} from './Timeline'

export enum Check {
	/** Mark an actor as targetable when it is first targeted by an event. */
	FIRST_TARGETED,
	/** Check actor updates for changes to actor targetability. */
	TARGETABLE,
	/** Consider an actor as untargetable on death. */
	DEATH,
	/**
	 * Consider an actor as untargetable on hitting 1HP or being overkilled.
	 * Use for actors that do not die in a typical manner.
	 */
	OVERKILL,
}

const DEFAULT_CHECKS = [
	Check.FIRST_TARGETED,
	Check.TARGETABLE,
	Check.DEATH,
]

interface IncludedActorConfig {
	/**
	 * Checks to perform to determine targetability.
	 * Defaults to [FIRST_TARGETED, TARGETABLE, DEATH].
	 */
	checks?: Check[]

	/**
	 * Mirror 'untargetable' invuln windows into 'invulnerable' windows.
	 * Default `true`. Disable for actors that take damage while untargetable -
	 * you will need to add custom logic to add the invulnerable windows yourself.
	 */
	mirrorToInvuln?: boolean
}

type ActorConfig =
	& {kind: Record<ReportMetaKey, Actor['kind']>}
	& (
		| {exclude: true}
		| ({exclude?: false} & IncludedActorConfig)
	)

export type ActorsConfig = ActorConfig[]

const SHARED_ACTOR_CONFIG: ActorsConfig = [
	// Exclude unknown actors
	{kind: {legacyFflogs: 'unknown'}, exclude: true},
]

const ALL_TYPES = ['invulnerable', 'untargetable'] as const
/**
 * Possible type of invulnerability.
 * - `invulnerable` - the actor cannot be damaged
 * - `untargetable` - the actor cannot be targted
 */
export type Type = (typeof ALL_TYPES)[number]

/** A period of time. */
export interface Window {
	start: number
	end: number
}

/**
 * The "side" of a window that an edge represents. The values of this enum are
 * _not_ arbitrary - they're used as part of the intersection algoritm. Don't
 * change them.
 */
enum EdgeSide {
	START = 1,
	END = -1,
}

/**
 * Representation of a boundary between a type being active and inactive, or
 * visa versa.
 */
interface Edge {
	/** ID representing the pairing of a START edge with its corresponding END edge. */
	id: number
	side: EdgeSide
	timestamp: number
}

/** Options available to narrow considered data when merging ranges. */
export interface WindowFilter {
	/** Earliest point in time to consider. Defaults to the time of the pull. */
	start?: number
	/** Latest point in time to consider. Defaults to the current timestamp. */
	end?: number
	/** Invulnerability types to consider. Defaults to all possible types. */
	types?: readonly Type[]
	/**
	 * Filter to select actors that should be considered. Defaults to selecting
	 * all actors on the FOE team.
	 */
	actorFilter?: (actor: Actor) => boolean
}

const DEFAULT_ACTOR_FILTER = filter<Actor>().team(Team.FOE)

export class Invulnerability extends Analyser {
	static override handle = 'invulnerability'
	static override debug = false

	@dependency private timeline!: Timeline

	/**
	 * Array of configuration overrides. The default configuration should be fine
	 * for most actors - add an override if the derived invulnerability windows
	 * look wrong.
	 */
	protected actorConfig: ActorConfig[] = []

	private watchedActors = new Set<Actor>()
	private skipMirroring = new Set<Actor['id']>()
	private seenActors = new Set<Actor['id']>()
	private edges = new Map<Actor['id'], Record<Type, Edge[]>>()

	private nextEdgeId = 0
	private getNextEdgeId = () => this.nextEdgeId++

	// =====
	// #region Public API
	// =====

	isActive({
		timestamp = this.parser.currentEpochTimestamp,
		...rest
	}: Omit<WindowFilter, 'start' | 'end'> & {timestamp?: number}): boolean {
		const windows = this.getWindows({
			...rest,
			start: timestamp,
			end: timestamp,
		})
		return windows.length > 0
	}

	getDuration(filter?: WindowFilter): number {
		const windows = this.getWindows(filter)
		return windows.reduce(
			(total, window) => total + (window.end - window.start),
			0,
		)
	}

	getWindows({
		start: rawStart = this.parser.pull.timestamp,
		end: rawEnd = this.parser.currentEpochTimestamp,
		types = ALL_TYPES,
		actorFilter = DEFAULT_ACTOR_FILTER,
	}: WindowFilter = {}): Window[] {
		// Ensure that the start is during the pull, and the end is not behind it.
		// We also ensure that the requested window is at minimum 1ms long to prevent
		// the following algorithm from trying to calculate a window with no duration.
		const start = Math.max(rawStart, this.parser.pull.timestamp - 1)
		const end = Math.max(rawEnd, rawStart + 1)

		// We track the expected total depth - equiv to number of matched actors
		// times requested types - to ensure we only catch full-invuln windows
		let expectedDepth = 0

		// Collect all edges matching the filter
		const edges: Edge[] = []
		for (const actor of this.watchedActors) {
			if (!actorFilter(actor)) { continue }

			expectedDepth += types.length

			for (const type of types) {
				// Fetch edges for this actor under the current type. No edges reliably
				// means the actor was available for the type for the full duration,
				// which in turn implies we can just shortcut the rest of the method.
				const typeEdges = this.edges.get(actor.id)?.[type]
				if (typeEdges == null || typeEdges.length === 0) { return [] }

				const rangeEdges = this.getEdgesInRange(typeEdges, start, end)

				// No edges within the narrowed range likewise implies full availability
				if (rangeEdges.length === 0) { return [] }

				edges.push(...rangeEdges)
			}
		}

		// Sort edges by their timestamp. When equal, sort with preference towards
		// maintaining ID pairings. This relies on the values of EdgeSide.
		edges.sort((a, b) => {
			const delta = a.timestamp - b.timestamp
			return delta !== 0
				? delta
				: a.side - b.side * (a.id === b.id ? -1 : 1)
		})

		// Trace the current depth of started edges
		let depth = 0

		const windows: Window[] = []
		for (let index = 0; index < edges.length; index++) {
			const edge = edges[index]
			depth += edge.side

			if (depth !== expectedDepth) { continue }

			// If the current depth matches expectation, we've got a deepest possible
			// match, signifying a window matching the filter
			windows.push({
				start: edge.timestamp,
				end: edges[index + 1].timestamp,
			})
		}

		return windows
	}

	/**
	 * Given a sorted collection of edges, get any within the specified time range.
	 * Results will be sanity checked to ensure windows are fully represented.
	 */
	private getEdgesInRange(edges: readonly Edge[], start: number, end: number): Edge[] {
		// We track the most recent side when iterating as it indicates the opening
		// status of a range
		let lastSide = EdgeSide.END

		// Get an array of all edges stictly within the specified range
		const rangeEdges: Edge[] = []
		for (const edge of edges) {
			if (edge.timestamp > end) { break }
			lastSide = edge.side
			if (edge.timestamp < start) { continue }
			rangeEdges.push(edge)
		}

		if (rangeEdges.length === 0) {
			// An empty range with a recent end implies no spanning window
			if (lastSide === EdgeSide.END) { return [] }

			// Conversely, a recent start implies full duration
			const id = this.getNextEdgeId()
			return [
				{id, side: EdgeSide.START, timestamp: start},
				{id, side: EdgeSide.END, timestamp: end},
			]
		}

		// Hem windows on both sides of the shortened range
		if (rangeEdges[0].side === EdgeSide.END) {
			rangeEdges.unshift({
				id: rangeEdges[0].id,
				side: EdgeSide.START,
				timestamp: start,
			})
		}

		const lastEdge = rangeEdges[rangeEdges.length - 1]
		if (lastEdge.side === EdgeSide.START) {
			rangeEdges.push({
				id: lastEdge.id,
				side: EdgeSide.END,
				timestamp: end,
			})
		}

		return rangeEdges
	}

	// =====
	// #endregion
	// #region Tracking
	// =====

	override initialise() {
		const reportSource = this.parser.report.meta.source

		// Flatten any subclass actor config to a map by the current report sources'
		// kind keys, for faster lookups later.
		const flatConfig = new Map([...SHARED_ACTOR_CONFIG, ...this.actorConfig].map(config => [
			config.kind[reportSource],
			config,
		]))

		// Group actors by the checks that should be performed on them.
		const actorChecks = new Map<Check, Array<Actor['id']>>()
		for (const actor of this.parser.pull.actors) {
			// Skip player-controlled actors and their pets
			// TODO: This is primarily for consistency with old systems. Consider if it's feasible to track PCs.
			if (this.isPlayerDerived(actor)) {
				continue
			}

			const config = flatConfig.get(actor.kind)

			// If the actor has been explicitly excluded, skip it entirely
			if (config != null && config.exclude) {
				continue
			}

			this.watchedActors.add(actor)

			// Check if this actor should not be mirrored
			if (config?.mirrorToInvuln === false) {
				this.skipMirroring.add(actor.id)
			}

			// Add the actor to each of the check keys it is configured for
			const checks = config?.checks ?? DEFAULT_CHECKS
			for (const check of checks) {
				let actorIds = actorChecks.get(check)
				if (actorIds == null) {
					actorIds = []
					actorChecks.set(check, actorIds)
				}
				actorIds.push(actor.id)
			}
		}

		// Set up hooks for each check
		const addHooksFns: Record<Check, (actorIds: Array<Actor['id']>) => void> = {
			[Check.TARGETABLE]: this.addTargetableHooks,
			[Check.DEATH]: this.addDeathHooks,
			[Check.OVERKILL]: this.addOverkillHooks,
			[Check.FIRST_TARGETED]: this.addFirstTargetedHooks,
		}
		for (const [check, ids] of actorChecks) {
			addHooksFns[check](ids)
		}

		this.debug(() => this.addEventHook('complete', this.renderDebugTimelineData))
	}

	private isPlayerDerived = (actor: Actor): boolean => false
		|| actor.playerControlled
		|| (actor.owner != null && this.isPlayerDerived(actor.owner))

	private addTargetableHooks = (actorIds: Array<Actor['id']>) => {
		// Preemptively start the first window at the beginning of the fight in case
		// the actor has been configured without first targeted
		for (const id of actorIds) {
			this.addStartEdge(id, -1)
		}

		this.addEventHook(
			filter<Event>()
				.type('actorUpdate')
				.actor(oneOf(actorIds))
				.targetable(exists),
			event => {
				// This should never be hit, but sanity check anyway
				if (event.targetable == null) { return }

				event.targetable
					? this.addEndEdge(event.actor, event.timestamp)
					: this.addStartEdge(event.actor, event.timestamp)
			}
		)
	}

	private addDeathHooks = (actorIds: Array<Actor['id']>) => {
		this.addEventHook(
			filter<Event>()
				.type('actorUpdate')
				.actor(oneOf(actorIds))
				.hp(filter<Resource>().current(0)),
			event => this.addStartEdge(event.actor, event.timestamp),
		)
	}

	private addOverkillHooks = (actorIds: Array<Actor['id']>) => {
		// Hook both overkill and an update to 1HP to ensure all cases are caught
		type EventDamageTargets = Events['damage']['targets']
		this.addEventHook(
			filter<Event>()
				.type('damage')
				.targets((t: EventDamageTargets): t is EventDamageTargets => t.some(target => actorIds.includes(target.target) && target.overkill > 0)),
			event => {
				event.targets.forEach(t => {
					if (actorIds.includes(t.target) && t.overkill > 0) {
						this.addStartEdge(t.target, event.timestamp)
					}
				})
			},
		)
		this.addEventHook(
			filter<Event>()
				.type('actorUpdate')
				.actor(oneOf(actorIds))
				.hp(filter<Resource>().current(1)),
			event => this.addStartEdge(event.actor, event.timestamp),
		)
	}

	private addFirstTargetedHooks = (actorIds: Array<Actor['id']>) => {
		// Preemptively start the first window at the beginning of time. This will
		// fall well outside the fight bounds (1970) - it will be constrained
		// elsewhere. We do this to avoid potential errors caused by prepull logic
		// causing time backtracking.
		for (const id of actorIds) {
			this.addStartEdge(id, -1)
		}

		// Handle damage and heal event types separately because they have multi-target support and a different structure than other events
		type EventMultiTargets = Events['damage' | 'heal']['targets']
		this.addEventHook(
			filter<Event>()
				.type(oneOf(['damage', 'heal']))
				.targets((t: EventMultiTargets): t is EventMultiTargets => t.some(target => actorIds.includes(target.target))),
			event => {
				event.targets.forEach(t => {
					if (actorIds.includes(t.target)) {
						this.trackIfFirstTarget(event.source, t.target, event.timestamp)
					}
				})
			}
		)

		// Exclude status updates, it's relatively common for player statuses to be mirrored to
		// untargetable actors, and we don't want that to crop up and cause issues.
		// Also exclude damage and heal as they're handled separately above due to their different signature
		const ensureEventTypes = <T extends Event['type']>(types: T[]) => types
		const ignoredTypes = ensureEventTypes(['statusApply', 'statusRemove', 'damage', 'heal'])

		// This is basically an inverse oneOf
		// TODO: Look into genericising this. Will require some type hackery in filter, hence not doing right now.
		type PermittedTypes = TB.Union.Filter<
			Event['type'],
			(typeof ignoredTypes) extends Array<infer T> ? T : never
		>
		const ignoredTypesSet = new Set<Event['type']>(ignoredTypes)
		const matchType = (value: Event['type']): value is PermittedTypes => !ignoredTypesSet.has(value)

		// Track actors that have been seen so they may be skipped. If you're thinking
		// of copying this pattern, probably don't - preference adding temporary hooks
		// that you remove once they've done their job. This is only implemented with
		// a single hook here due to the majority of the 100+ mechanic actors common in
		// complex fights never removing their hook, and just chew unnessecary time.
		this.addEventHook(
			filter<Event>()
				.type(matchType)
				.target(oneOf(actorIds)),
			event => this.trackIfFirstTarget(event.source, event.target, event.timestamp)
		)
	}

	private trackIfFirstTarget(sourceId: string, targetId: string, timestamp: number) {
		if (this.seenActors.has(targetId) || sourceId === targetId) {
			return
		}

		this.addEndEdge(targetId, timestamp)
	}

	private addStartEdge = (actorId: Actor['id'], timestamp: number) =>
		this.mirrorTypeEdge(this.addTypeStartEdge, actorId, timestamp)

	private addEndEdge(actorId: Actor['id'], timestamp: number) {
		this.mirrorTypeEdge(this.addTypeEndEdge, actorId, timestamp)

		// It's not uncommon for some checks such as TARGETABLE to close a window before
		// the actor is first targeted - mark any actors we close a window on as seen
		// so as to ignore them for the FIRST_TARGETED check
		this.seenActors.add(actorId)
	}

	private mirrorTypeEdge(
		fn: (type: Type, actorId: Actor['id'], timestamp: number) => void,
		actorId: Actor['id'],
		timestamp: number,
	) {
		// Start the untargetable window, mirroring to invuln if configured to do so
		fn('untargetable', actorId, timestamp)
		if (!this.skipMirroring.has(actorId)) {
			fn('invulnerable', actorId, timestamp)
		}
	}

	private addTypeStartEdge = (type: Type, actorId: Actor['id'], timestamp: number) => {
		const edges = this.getActorEdges(actorId)

		const typeEdges = edges[type]
		const lastEdge = typeEdges[typeEdges.length - 1] as Edge | undefined

		// If the previous edge is a start, we can just piggyback on it.
		if (lastEdge != null && lastEdge.side === EdgeSide.START) {
			return
		}

		typeEdges.push({
			id: this.getNextEdgeId(),
			side: EdgeSide.START,
			timestamp,
		})
	}

	private addTypeEndEdge = (type: Type, actorId: Actor['id'], timestamp: number) => {
		const edges = this.getActorEdges(actorId)

		const typeEdges = edges[type]
		const lastEdge = typeEdges[typeEdges.length - 1] as Edge | undefined

		// If there's no currently open window (a trailing START), we can't really
		// end anything, as backtracking would effectively change history that may
		// have already been read. This typically only happens in dungeons and such.
		if (lastEdge?.side !== EdgeSide.START) {
			this.debug(`Actor ${actorId} has no ${type} window to end.`)
			return
		}

		typeEdges.push({
			id: lastEdge.id,
			side: EdgeSide.END,
			timestamp,
		})
	}

	private getActorEdges(actor: Actor['id']) {
		let edges = this.edges.get(actor)
		if (edges == null) {
			edges = {
				invulnerable: [],
				untargetable: [],
			}
			this.edges.set(actor, edges)
		}
		return edges
	}

	// =====
	// #endregion
	// #region Debug output
	// =====

	private renderDebugTimelineData() {
		const parentRow = this.timeline.addRow(new SimpleRow({
			label: 'Invuln2 Debug',
			order: -Infinity,
		}))

		const kindRows = new Map<Actor['kind'], SimpleRow>()

		for (const actor of this.watchedActors) {
			let kindRow = kindRows.get(actor.kind)
			if (kindRow == null) {
				const variousNames = this.parser.pull.actors
					.some(otherActor => otherActor.kind === actor.kind && otherActor.name !== actor.name)
				kindRow = parentRow.addRow(new SimpleRow({
					label: `${variousNames ? '[various]' : actor.name} (${actor.kind})`,
					collapse: true,
				}))
				kindRows.set(actor.kind, kindRow)

				const allRow = kindRow.addRow(new SimpleRow({
					label: 'all',
					collapse: true,
				}))

				this.buildDebugTypeRows(
					allRow,
					filterActor => filterActor.kind === actor.kind,
				)
			}

			const actorRow = kindRow.addRow(new SimpleRow({
				label: `${actor.name} (${actor.id})`,
				collapse: true,
				hideCollapsed: true,
			}))

			this.buildDebugTypeRows(
				actorRow,
				filterActor => filterActor.id === actor.id,
			)
		}
	}

	private buildDebugTypeRows(parentRow: SimpleRow, actorFilter: WindowFilter['actorFilter']) {
		const startTime = this.parser.pull.timestamp
		const endTime = startTime + this.parser.pull.duration

		for (const type of ALL_TYPES) {
			const typeRow = parentRow.addRow(new SimpleRow({
				label: type,
			}))

			const windows = this.getWindows({types: [type], actorFilter})
			for (const window of windows) {
				if (window.start <= startTime && window.end >= endTime) { continue }

				typeRow.addItem(new SimpleItem({
					start: window.start - startTime,
					end: window.end - startTime,
					content: <div style={{width: '100%', height: '100%', backgroundColor: '#faa8'}}/>,
				}))
			}
		}
	}

	// =====
	// #endregion
	// =====
}
