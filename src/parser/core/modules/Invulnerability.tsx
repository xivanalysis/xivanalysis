import Module, {dependency} from '../Module'
import {Event} from 'events'
import {Actor, ActorType} from 'fflogs'
import React from 'react'
import {Timeline, SimpleItem, SimpleRow} from './Timeline'
import {AdditionalEvents, AdditionalEventQueries} from './AdditionalEvents'
import {isDefined} from 'utilities'

// Config for legacy invulnerability logic
const MIN_INVULN_INACTIVITY = 5000 // 5s
const ACTIVITY_EVENT_TYPES = ['begincast', 'damage', 'heal']

// Logs prior to this date will use the old logic
const TARGETABLE_EVENT_IMPLEMENTATION_DATE = new Date('2019-08-05')

type InvulnActor = Actor['id'] | 'all'
type InvulnInstance = number | 'all'
type InvulnTarget = InvulnActor | [InvulnActor, InvulnInstance]
type InvulnType = 'invulnerable' | 'untargetable'

interface ActiveInvulnActorConfig {
	/**
	 * Check logic to use to calculate when an actor is targetable.
	 * Default `tau`. Use `firstTap` when no TAU events are present.
	 */
	start?: 'tau' | 'firstTap'

	/**
	 * Check logic to use to calculate when an actor is untargetable.
	 * Default `tau`. Use `overkill` when no TAU events are present.
	 */
	end?: 'tau' | 'overkill'

	/**
	 * Mirror 'untargetable' invuln windows into 'invulnerable' windows.
	 * Default `true`. Disable for actors that take damage while untargetable -
	 * you will need to add custom logic to add the invulnerable windows yourself.
	 */
	mirrorToInvuln?: boolean
}

type InvulnActorConfig =
	| {exclude: true}
	| ({exclude?: false} & ActiveInvulnActorConfig)

export type ActorsConfig = Partial<Record<Actor['guid'], InvulnActorConfig>>

interface InvulnWindow {
	type: InvulnType
	active?: boolean
	start: number
	end: number
}

type LegacyLastHit = Record<InvulnType, number>

export class Invulnerability extends Module {
	static handle = 'invuln'
	static debug = false

	@dependency private additionalEventQueries!: AdditionalEventQueries
	@dependency private additionalEvents!: AdditionalEvents
	@dependency private timeline!: Timeline

	protected actorConfig: ActorsConfig = {}

	private legacyLastHit: Partial<Record<InvulnActor, LegacyLastHit>> = {}

	private invulns = new Map<InvulnActor, Map<InvulnInstance, InvulnWindow[]>>()
	private firstTaps = new Set<string>()
	private guidCache = new Map<Actor['id'], Actor['guid'] | undefined>()

	private get legacyMode() {
		const implDate = TARGETABLE_EVENT_IMPLEMENTATION_DATE.getTime() / 1000
		return this.parser.parseDate < implDate
	}

	protected init() {
		this.addEventHook(
			'complete',
			() => this.debug(() => this.renderDebugTimelineData()),
		)

		if (!this.legacyMode) {
			this.registerEventQueries()
		}
	}

	// -----
	// Query building
	// -----

	private registerEventQueries() {
		this.additionalEventQueries.registerQuery("type in ('targetabilityupdate','death')")

		const actorQueries: Array<string | undefined> = []
		for (const [strActGuid, config] of Object.entries(this.actorConfig)) {
			// Skip excluded actors, we'll be excluding them during processing
			if (config == null || config.exclude) {
				continue
			}

			const actorGuid = Number(strActGuid)
			if (config.start === 'firstTap') { actorQueries.push(this.buildFirstTapQuery(actorGuid)) }
			if (config.end === 'overkill') { actorQueries.push(this.buildOverkillQuery(actorGuid)) }
		}
		if (actorQueries.length > 0) {
			this.additionalEventQueries.registerQuery(actorQueries.filter(isDefined).join(' or '))
		}
	}

	private buildFirstTapQuery(actorGuid: Actor['guid']) {
		const actorFightData = this.parser.report.enemies
			.find(enemy => enemy.guid === actorGuid)
			?.fights
			.find(fight => fight.id === this.parser.fight.id)

		// If the actor did not participate in the current log, bail out - likely a kill before they appear
		if (actorFightData == null) {
			this.debug(`Actor ${actorGuid} did not participate in fight ${this.parser.fight.id} - skipping firstTap query`)
			return
		}

		const instanceCount = actorFightData.instances

		// I'm not currently handling the edge case where an "excluded" actor needs a firstTap
		// If that's ever required, we'll need to do some nasty shit to work out instance counts
		// from the event data to fulfil this query's requirements
		if (instanceCount == null || instanceCount === 0) {
			throw new Error(`Could not find instance count for actor ${actorGuid}`)
		}

		// If there's only one instance of an actor in a fight, fflogs omits the instance from
		// the event entirely. Work around that.
		if (instanceCount === 1) {
			return `matched target.id=${actorGuid} in (1) end`
		}

		// Hold onta ya hats bois, it's boutta get real ugly
		const matchedQueries = [...Array(instanceCount)].map(
			(_, index) => `matched target.id=${actorGuid} and target.instance=${index+1} in (1) end`,
		)

		return `(${matchedQueries.join(' or ')})`
	}

	private buildOverkillQuery = (actorGuid: Actor['guid']) =>
		`(target.id=${actorGuid} and (targetResources.hitPoints=1 or overkill>0))`

	// -----
	// Normalise
	// -----

	normalise(events: Event[]) {
		const processFn = this.legacyMode
			? this.processLegacyLogEvent
			: this.processLogEvent

		for (const event of events) {
			processFn.call(this, event)
		}

		if (!this.legacyMode) {
			this.mergeAllWindows()
		}

		return events
	}

	// -----
	// Legacy invuln logic
	// -----

	private processLegacyLogEvent(event: Event) {
		// Avoid processing symbol events early
		if (typeof event.type === 'symbol') {
			return
		}

		const target = event.targetID
		const playerId = this.parser.player.id

		if (
			// Make sure it's got all the info we care about, and we're tracking it
			!ACTIVITY_EVENT_TYPES.includes(event.type) ||
			!target ||
			!event.sourceID ||

			// we only care about casts and heals by the player onto something other than themselves
			(['begincast', 'heal'].includes(event.type) && (
				!event.sourceIsFriendly ||
				event.sourceID !== playerId ||
				event.sourceID === target
			)) ||

			// damage done to players happens all the time, ignore it
			(event.type === 'damage' && event.targetIsFriendly)
		) { return }

		if (!event.targetIsFriendly) {
			this.legacyCheckLastHits(target, event)
		}
		this.legacyCheckLastHits('all', event)
	}

	private legacyCheckLastHits(target: InvulnActor, event: Event) {
		const enemyLastHits = this.legacyLastHit[target] || {
			invulnerable: event.timestamp,
			untargetable: event.timestamp,
		}
		// Invuln
		this.legacyCheckForType(target, enemyLastHits, 'invulnerable', event)

		// Untargetable
		// NOTE: This `any` is required, unfortunately, to preserve the legacy logic.
		if ((!(event as any).tick)) {
			this.legacyCheckForType(target, enemyLastHits, 'untargetable', event)
		}

		this.legacyLastHit[target] = enemyLastHits
	}

	private legacyCheckForType(
		target: InvulnActor,
		lastHits: LegacyLastHit,
		type: keyof LegacyLastHit,
		event: Event,
	) {
		const last = lastHits[type]
		const timeSince = event.timestamp - last

		if (timeSince > MIN_INVULN_INACTIVITY) {
			this.getInvulns(target).push({
				type,
				start: last,
				end: event.timestamp,
			})
		}

		lastHits[type] = event.timestamp
	}

	// -----
	// TAU-based invuln logic
	// -----

	private processLogEvent(event: Event) {
		// "Unknown" type mobs sometimes generate TAUs, but do not have a stable ID or GUID.
		// I'm yet to see a single one that is actually targetable - exclude them for now.
		if (event.target?.type === ActorType.UNKNOWN) { return }

		// Try to get a guid - if we can't, bail early
		const guid = this.getEventTargetGuid(event)
		if (guid == null) { return }

		// Grab the actor config if there is any. Explicitly excluded actors can bail early.
		const config = this.actorConfig[guid] ?? {}
		if (config.exclude) { return }

		// Build the list of checks we'll need to do for this actor
		// TODO: Maybe this should be cached rather than the guid?
		const {start = 'tau', end = 'tau'} = config
		const checks = []

		if (start === 'tau' || end === 'tau') {
			checks.push(this.checkTau)
		}

		if (end === 'tau') {
			checks.push(this.checkDeath)
		}

		if (start === 'firstTap') {
			checks.push(this.checkFirstTap)
		}

		if (end === 'overkill') {
			checks.push(this.checkOverkill)
		}

		// Execute the checks
		const target = this.getEventTargetKey(event)
		checks.forEach(check => check.call(this, target, config, event))
	}

	private getEventTargetGuid(event: Event) {
		// There's a few places guids are stored in log data - derive the guid for
		// the target of the event, caching if appropriate
		let guid = event.target?.guid
		if (guid != null) { return guid }

		if (event.targetID == null) {
			return undefined
		}

		if (this.guidCache.has(event.targetID)) {
			return this.guidCache.get(event.targetID)
		}

		guid = this.parser.report.enemies.find(enemy => enemy.id === event.targetID)?.guid
		this.guidCache.set(event.targetID, guid)

		return guid
	}

	private getEventTargetKey = (event: Event): InvulnTarget =>
		// TODO: the -1 here is a bit nasty - might want an `assertDefined`
		[event.targetID ?? event.target?.id ?? -1, event.targetInstance ?? 1]

	// Check windows using the targetabilityupdate log event
	private checkTau(target: InvulnTarget, config: ActiveInvulnActorConfig, event: Event) {
		if (event.type !== 'targetabilityupdate' || event.targetIsFriendly) {
			return
		}

		if (!event.targetable) {
			// target -> untarget
			this.startWindow(target, config, event.timestamp)
		} else {
			// untarget -> target
			this.endWindow(target, config, event.timestamp)
		}
	}

	// Mark the start of invuln windows on actor death
	private checkDeath(target: InvulnTarget, config: ActiveInvulnActorConfig, event: Event) {
		if (event.type !== 'death' || event.targetIsFriendly) {
			return
		}

		this.startWindow(target, config, event.timestamp)
	}

	// Mark the end of an "invuln" window on the first event to target an actor
	// Only used if TAU does not function for an actor
	private checkFirstTap(target: InvulnTarget, config: ActiveInvulnActorConfig, event: Event) {
		const key = Array.isArray(target) ? target.join(':') : String(target)

		if (this.firstTaps.has(key)) {
			return
		}

		this.firstTaps.add(key)
		this.endWindow(target, config, event.timestamp)
	}

	// Mark the start of an invuln window on the killing blow event for an actor
	// Only used if Death does not function for an actor
	private checkOverkill(target: InvulnTarget, config: ActiveInvulnActorConfig, event: Event) {
		if (event.type !== 'damage') {
			return
		}

		if ((event.overkill ?? 0) > 0 || event.targetResources.hitPoints === 1) {
			this.startWindow(target, config, event.timestamp)
		}
	}

	private startWindow(target: InvulnTarget, config: ActiveInvulnActorConfig, start: number) {
		this.startTypeWindow('untargetable', target, start)
		if (config.mirrorToInvuln ?? true) {
			this.startTypeWindow('invulnerable', target, start)
		}
	}

	private endWindow(target: InvulnTarget, config: ActiveInvulnActorConfig, end: number) {
		this.endTypeWindow('untargetable', target, end)
		if (config.mirrorToInvuln ?? true) {
			this.endTypeWindow('invulnerable', target, end)
		}
	}

	private startTypeWindow(type: InvulnType, target: InvulnTarget, start: number) {
		const invulns = this.getInvulns(target)

		// If there's an active invuln already, piggyback on it rather than starting a new one
		const activeInvuln = invulns.find(invuln => invuln.active && invuln.type === type)
		if (activeInvuln != null) {
			return activeInvuln
		}

		const window = {
			active: true,
			type,
			start,
			end: this.parser.pull.duration + this.parser.eventTimeOffset,
		} as const
		invulns.push(window)
		return window
	}

	private endTypeWindow(type: InvulnType, target: InvulnTarget, end: number) {
		const invulns = this.getInvulns(target)
		let activeInvuln = invulns.find(invuln => invuln.active && invuln.type === type)

		// == null means something became targetable, but never went untargetable
		// we can presume it has been untargetable since the start of the fight
		if (activeInvuln == null) {
			activeInvuln = this.startTypeWindow(type, target, this.parser.eventTimeOffset)
		}

		activeInvuln.active = false
		activeInvuln.end = end
	}

	private mergeAllWindows() {
		// Compile all the instance sets into an 'all' for each actor, saving out the all data as we go
		const actorWindowGroups: InvulnWindow[][] = []
		for (const instanceWindows of this.invulns.values()) {
			const actorWindow = this.mergeInputWindows(instanceWindows.values())
			instanceWindows.set('all', actorWindow)
			actorWindowGroups.push(actorWindow)
		}

		// Use the list of actor 'all's to compile ['all', 'all']
		const allWindows = this.mergeInputWindows(actorWindowGroups)
		this.getInvulns('all').push(...allWindows)
	}

	private mergeInputWindows(inputWindowGroups: Iterable<Iterable<InvulnWindow>>): InvulnWindow[] {
		const start = this.parser.eventTimeOffset
		const end = start + this.parser.pull.duration

		// Start with a full-length window, we'll chip time out of it from the input
		let outputWindows: InvulnWindow[] = [{
			type: 'untargetable',
			start,
			end,
		}, {
			type: 'invulnerable',
			start,
			end,
		}]
		let hasInput = false

		for (const inputWindows of inputWindowGroups) {
			// Get a reference to the current windows, and reset
			// TODO: This may fail when an actor has 1+ of one invuln type, and 0 of the other
			//       Test. Potential fix is to hold output for each type seperately and merge after compile
			const currentWindows = outputWindows
			outputWindows = []

			for (const inputWindow of inputWindows) {
				hasInput = true

				// Find existing windows that intersect with this one, and push it to the output, bounded
				// by the limits of the intersection
				const intersectingWindows = currentWindows.filter(window =>
					window.end >= inputWindow.start &&
					window.start <= inputWindow.end &&
					window.type === inputWindow.type,
				)
				intersectingWindows.forEach(window => {
					outputWindows.push({
						type: window.type,
						start: Math.max(window.start, inputWindow.start),
						end: Math.min(window.end, inputWindow.end),
					})
				})
			}
		}

		// If there was no input, the initial state of a full-length window is erraneous - return empyu
		if (!hasInput) {
			return []
		}

		return outputWindows
	}

	// -----
	// Event handlers
	// -----

	private renderDebugTimelineData() {
		const startTime = this.parser.eventTimeOffset

		const parentRow = this.timeline.addRow(new SimpleRow({
			label: 'Invuln Debug',
			order: -Infinity,
		}))

		this.invulns.forEach((value, actorId) => {
			const actor = this.parser.report.enemies.find(enemy => enemy.id === actorId)
			const actorRow = parentRow.addRow(new SimpleRow({
				label: actor != null
					? `(${actor.guid}) ${actor.name}`
					: actorId,
				hideCollapsed: actorId !== 'all',
				collapse: true,
			}))

			value.forEach((value, instanceId) => {
				const instanceRow = actorRow.addRow(new SimpleRow({
					label: instanceId,
					hideCollapsed: instanceId !== 'all',
				}))

				const invulnRow = instanceRow.addRow(new SimpleRow({
					label: 'invulnerable',
				}))
				const untargetRow = instanceRow.addRow(new SimpleRow({
					label: 'untargetable',
				}))

				value.forEach(window => {
					const row = window.type === 'invulnerable' ? invulnRow : untargetRow
					row.addItem(new SimpleItem({
						start: window.start - startTime,
						end: window.end - startTime,
						content: <div style={{width: '100%', height: '100%', backgroundColor: '#faa'}}/>,
					}))
				})
			})
		})
	}

	// -----
	// Public API
	// -----

	isUntargetable = (
		targetId: InvulnTarget = 'all',
		time = this.parser.currentTimestamp,
	) => this.checkInvuln(targetId, time, 'untargetable')
	isInvulnerable = (
		targetId: InvulnTarget = 'all',
		time = this.parser.currentTimestamp,
	) => this.checkInvuln(targetId, time, 'invulnerable')

	getUntargetableUptime = (
		targetId: InvulnTarget = 'all',
		start = 0,
		end = this.parser.currentTimestamp,
	) => this.getInvulnUptime(targetId, start, end, 'untargetable')
	getInvulnerableUptime = (
		targetId: InvulnTarget = 'all',
		start = 0,
		end = this.parser.currentTimestamp,
	) => this.getInvulnUptime(targetId, start, end, 'invulnerable')

	getInvulns(
		targetId: InvulnTarget = 'all',
		start?: number,
		end?: number,
		type?: InvulnType,
	) {
		const [actorId, instanceId] = Array.isArray(targetId)
			? targetId
			: [targetId, 'all'] as const

		let instanceInvulns = this.invulns.get(actorId)
		if (instanceInvulns == null) {
			instanceInvulns = new Map()
			this.invulns.set(actorId, instanceInvulns)
		}

		let invulns = instanceInvulns.get(instanceId)
		if (invulns == null) {
			invulns = []
			instanceInvulns.set(instanceId, invulns)
		}

		if (start || end || type) {
			invulns = invulns.filter(invuln => {
				if (type && invuln.type !== type) { return false }
				if (start && invuln.end < start) { return false }
				if (end && invuln.start > end) { return false }
				return true
			})
		}

		return invulns
	}

	private getInvulnUptime(
		targetId: InvulnTarget,
		start: number,
		end: number,
		type: InvulnType,
	) {
		return this.getInvulns(targetId, start, end, type)
			.reduce((uptime, invuln) => uptime + Math.min(invuln.end, end) - Math.max(invuln.start, start), 0)
	}

	private checkInvuln(
		targetId: InvulnTarget,
		time: number,
		type: InvulnType,
	) {
		const filtered = this.getInvulns(targetId).filter(invuln =>
			invuln.type === type &&
			invuln.start <= time &&
			invuln.end >= time,
		)

		return !!filtered.length
	}
}
