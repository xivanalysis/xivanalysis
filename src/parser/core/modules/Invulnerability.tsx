import Module, {dependency} from '../Module'
import {Event} from 'fflogs'
import React from 'react'
import {Timeline, SimpleItem} from './Timeline'

// Config for legacy invulnerability logic
const MIN_INVULN_INACTIVITY = 5000 // 5s
const ACTIVITY_EVENT_TYPES = ['begincast', 'damage', 'heal']

// Logs prior to this date will use the old logic
const TARGETABLE_EVENT_IMPLEMENTATION_DATE = new Date('2019-08-05')

type InvulnerabilityTarget = number | 'all'
type InvulnerabilityType = 'invulnerable' | 'untargetable'

type LegacyLastHit = Record<InvulnerabilityType, number>
interface LegacyInvulnerability {
	type: InvulnerabilityType,
	start: number,
	end: number
}

export class Invulnerability extends Module {
	static handle = 'invuln'
	static debug = true

	@dependency private timeline!: Timeline

	private legacyLastHit: Partial<Record<InvulnerabilityTarget, LegacyLastHit>> = {}
	private legacyInvulns: Partial<Record<InvulnerabilityTarget, LegacyInvulnerability[]>> = {}

	private get legacyMode() {
		// TEMP
		return true

		const implDate = TARGETABLE_EVENT_IMPLEMENTATION_DATE.getTime() / 1000
		return this.parser.parseDate < implDate
	}

	protected init() {
		this.addEventHook('complete', this.onComplete)
	}

	normalise(events: Event[]) {
		const processFn = this.legacyMode
			? this.processLegacyLogEvent.bind(this)
			: this.processTargetableLogEvent.bind(this)

		for (const event of events) {
			processFn(event)
		}

		return events
	}

	// -----
	// Legacy invuln logic
	// -----

	private processLegacyLogEvent(event: Event) {
		// Avoid processing symbol events early
		if (typeof event.type === 'symbol') {
			return
		}

		const target = event.targetID
		const playerId = this.parser.player.id

		if (
			// Make sure it's got all the info we care about, and we're tracking it
			!ACTIVITY_EVENT_TYPES.includes(event.type) ||
			!target ||
			!event.sourceID ||

			// we only care about casts and heals by the player onto something other than themselves
			(['begincast', 'heal'].includes(event.type) && (
				!event.sourceIsFriendly ||
				event.sourceID !== playerId ||
				event.sourceID === target
			)) ||

			// damage done to players happens all the time, ignore it
			(event.type === 'damage' && event.targetIsFriendly)
		) { return }

		if (!event.targetIsFriendly) {
			this.legacyCheckLastHits(target, event)
		}
		this.legacyCheckLastHits('all', event)
	}

	private legacyCheckLastHits(target: InvulnerabilityTarget, event: Event) {
		const enemyLastHits = this.legacyLastHit[target] || {
			invulnerable: event.timestamp,
			untargetable: event.timestamp,
		}
		// Invuln
		this.legacyCheckForType(target, enemyLastHits, 'invulnerable', event)

		// Untargetable
		// NOTE: This `any` is required, unfortunately, to preserve the legacy logic.
		if ((!(event as any).tick)) {
			this.legacyCheckForType(target, enemyLastHits, 'untargetable', event)
		}

		this.legacyLastHit[target] = enemyLastHits
	}

	private legacyCheckForType(
		target: InvulnerabilityTarget,
		lastHits: LegacyLastHit,
		type: keyof LegacyLastHit,
		event: Event,
	) {
		const last = lastHits[type]
		const timeSince = event.timestamp - last

		if (timeSince > MIN_INVULN_INACTIVITY) {
			this.getInvulns(target).push({
				type,
				start: last,
				end: event.timestamp,
			})
		}

		lastHits[type] = event.timestamp
	}

	// -----
	// TAU-based invuln logic
	// -----

	private processTargetableLogEvent(event: Event) {
		// TODO
	}

	// -----
	// Event handlers
	// -----

	private onComplete() {
		const startTime = this.parser.fight.start_time

		// Add invulns to the timeline
		this.getInvulns().forEach(invuln => {
			this.timeline.addItem(new SimpleItem({
				start: invuln.start - startTime,
				end: invuln.end - startTime,
				// TODO: This but better?
				content: <div style={{width: '100%', height: '100%', backgroundColor: '#d5ddf666'}}/>,
			}))
		})
	}

	// -----
	// Public API
	// -----

	isUntargetable = (
		targetId: InvulnerabilityTarget = 'all',
		time = this.parser.currentTimestamp,
	) => this.checkInvuln(targetId, time, 'untargetable')
	isInvulnerable = (
		targetId: InvulnerabilityTarget = 'all',
		time = this.parser.currentTimestamp,
	) => this.checkInvuln(targetId, time, 'invulnerable')

	getUntargetableUptime = (
		targetId: InvulnerabilityTarget = 'all',
		start = 0,
		end = this.parser.currentTimestamp,
	) => this.getInvulnUptime(targetId, start, end, 'untargetable')
	getInvulnerableUptime = (
		targetId: InvulnerabilityTarget = 'all',
		start = 0,
		end = this.parser.currentTimestamp,
	) => this.getInvulnUptime(targetId, start, end, 'invulnerable')

	getInvulns(
		targetId: InvulnerabilityTarget = 'all',
		start?: number,
		end?: number,
		type?: InvulnerabilityType,
	) {
		let invulns = this.legacyInvulns[targetId]
		if (invulns == null) {
			this.legacyInvulns[targetId] = invulns = []
		}

		if (start || end || type) {
			invulns = invulns.filter(invuln => {
				if (type && invuln.type !== type) { return false }
				if (start && invuln.end < start) { return false }
				if (end && invuln.start > end) { return false }
				return true
			})
		}

		return invulns
	}

	private getInvulnUptime(
		targetId: InvulnerabilityTarget,
		start: number,
		end: number,
		type: InvulnerabilityType,
	) {
		return this.getInvulns(targetId, start, end, type)
			.reduce((uptime, invuln) => uptime + Math.min(invuln.end, end) - Math.max(invuln.start, start), 0)
	}

	private checkInvuln(
		targetId: InvulnerabilityTarget,
		time: number,
		type: InvulnerabilityType,
	) {
		const filtered = this.getInvulns(targetId).filter(invuln =>
			invuln.type === type &&
			invuln.start <= time &&
			invuln.end >= time,
		)

		return !!filtered.length
	}
}
