import {Event, Resource} from 'event'
import _ from 'lodash'
import React from 'react'
import {Actor, ReportMetaKey} from 'report'
import {Analyser} from '../Analyser'
import {exists, filter, oneOf} from '../filter'
import {dependency} from '../Injectable'
import {Actors} from './Actors'
import {SimpleItem, SimpleRow, Timeline} from './Timeline'

export enum Check {
	/** Mark an actor as targetable when it is first targeted by an event. */
	FIRST_TARGETED,
	/** Check actor updates for changes to actor targetability. */
	TARGETABLE,
	/** Consider an actor as untargetable on death. */
	DEATH,
	/**
	 * Consider an actor as untargetable on hitting 1HP or being overkilled.
	 * Use for actors that do not die in a typical manner.
	 */
	OVERKILL,
}

const DEFAULT_CHECKS = [
	Check.FIRST_TARGETED,
	Check.TARGETABLE,
	Check.DEATH,
]

interface IncludedActorConfig {
	/**
	 * Checks to perform to determine targetability.
	 * Defaults to [FIRST_TARGETED, TARGETABLE, DEATH].
	 */
	checks?: Check[]

	/**
	 * Mirror 'untargetable' invuln windows into 'invulnerable' windows.
	 * Default `true`. Disable for actors that take damage while untargetable -
	 * you will need to add custom logic to add the invulnerable windows yourself.
	 */
	mirrorToInvuln?: boolean
}

type ActorConfig =
	& {kind: Record<ReportMetaKey, Actor['kind']>}
	& (
		| {exclude: true}
		| ({exclude?: false} & IncludedActorConfig)
	)

export type ActorsConfig = ActorConfig[]

const sharedActorConfig: ActorsConfig = [
	// Exclude unknown actors
	{kind: {legacyFflogs: 'unknown'}, exclude: true},
]

type Type = 'invulnerable' | 'untargetable'

interface Window {
	type: Type
	active: boolean
	start: number
	end: number
}

export class Invulnerability extends Analyser {
	static handle = 'invulnerability'
	static debug = true

	@dependency private actors!: Actors
	@dependency private timeline!: Timeline

	/** @todo docs */
	protected actorConfig: ActorConfig[] = []

	private skipMirroring = new Set<Actor['id']>()
	private windows = new Map<Actor['id'], Window[]>()

	initialise() {
		const reportSource = this.parser.newReport.meta.source

		// Flatten any subclass actor config to a map by the current report sources'
		// kind keys, for faster lookups later.
		const flatConfig = new Map([...sharedActorConfig, ...this.actorConfig].map(config => [
			config.kind[reportSource],
			config,
		]))

		// Group actors by the checks that should be performed on them.
		const actorChecks = new Map<Check, Array<Actor['id']>>()
		for (const actor of this.parser.pull.actors) {
			// Skip player-controlled actors and their pets
			// TODO: This is primarily for consistency with old systems. Consider if it's feasible to track PCs.
			if (this.isPlayerDerived(actor)) {
				continue
			}

			const config = flatConfig.get(actor.kind)

			// If the actor has been explicitly excluded, skip it entirely
			if (config != null && config.exclude) {
				continue
			}

			// Check if this actor should not be mirrored
			if (config?.mirrorToInvuln === false) {
				this.skipMirroring.add(actor.id)
			}

			// Add the actor to each of the check keys it is configured for
			const checks = config?.checks ?? DEFAULT_CHECKS
			for (const check of checks) {
				let foo = actorChecks.get(check)
				if (foo == null) {
					foo = []
					actorChecks.set(check, foo)
				}
				foo.push(actor.id)
			}
		}

		// Set up hooks for each check
		const addHooksFns: Record<Check, (actorIds: Array<Actor['id']>) => void> = {
			[Check.TARGETABLE]: this.addTargetableHooks,
			[Check.DEATH]: this.addDeathHooks,
			[Check.OVERKILL]: this.addOverkillHooks,
			[Check.FIRST_TARGETED]: this.addFirstTargetedHooks,
		}
		for (const [check, ids] of actorChecks) {
			addHooksFns[check](ids)
		}

		// TODO: LEGACY?
		// probably should just allow narrowing support ranges and drop legacy range

		this.debug(() => this.addEventHook('complete', this.renderDebugTimelineData))
	}

	private isPlayerDerived = (actor: Actor): boolean => false
		|| actor.playerControlled
		|| (actor.owner != null && this.isPlayerDerived(actor.owner))

	private addTargetableHooks = (actorIds: Array<Actor['id']>) => {
		this.addEventHook(
			filter<Event>()
				.type('actorUpdate')
				.actor(oneOf(actorIds))
				.targetable(exists),
			event => {
				// This should never be hit, but sanity check anyway
				if (event.targetable == null) { return }

				event.targetable
					? this.endWindow(event.actor, event.timestamp)
					: this.startWindow(event.actor, event.timestamp)
			}
		)
	}

	private addDeathHooks = (actorIds: Array<Actor['id']>) => {
		// this.addEventHook('death', this.onDeath)
		// TODO: Look into generalising death for non-pc actors?
		this.addEventHook(
			filter<Event>()
				.type('actorUpdate')
				.actor(oneOf(actorIds))
				.hp(filter<Resource>().current(0)),
			event => this.startWindow(event.actor, event.timestamp),
		)
	}

	private addOverkillHooks = (actorIds: Array<Actor['id']>) => {
		// Hook both overkill and an update to 1HP to ensure all cases are caught
		this.addEventHook(
			filter<Event>()
				.type('damage')
				.target(oneOf(actorIds))
				.overkill((v): v is number => v > 0),
			event => this.startWindow(event.target, event.timestamp),
		)
		this.addEventHook(
			filter<Event>()
				.type('actorUpdate')
				.actor(oneOf(actorIds))
				.hp(filter<Resource>().current(1)),
			event => this.startWindow(event.actor, event.timestamp),
		)
	}

	private addFirstTargetedHooks = (actorIds: Array<Actor['id']>) => {
		for (const id of actorIds) {
			// Preemptively start the first window at the beginning of the fight
			this.startWindow(id, this.parser.pull.timestamp)

			// Adding temporary hooks rather than one generalised one so we
			// can selectively remove them as they are targeted
			// TODO: that's >100 actors sometimes. worth it? probably not tbqh.

			const hook = this.addEventHook(
				{target: id},
				event => {
					// skip self target (filter?)
					if (event.target === event.source) {
						return
					}

					// type filter - probs should whitelist? duno, would be nice to type a not
					if (event.type === 'statusApply' || event.type === 'statusRemove') {
						return
					}

					this.removeEventHook(hook)
					this.endWindow(event.target, event.timestamp)
				},
			)
		}
	}

	private startWindow = (actorId: Actor['id'], timestamp: number) =>
		this.manageConfigWindows(this.startTypeWindow, actorId, timestamp)

	private endWindow = (actorId: Actor['id'], timestamp: number) =>
		this.manageConfigWindows(this.endTypeWindow, actorId, timestamp)

	// TODO: is this needed?
	private manageConfigWindows(
		fn: (type: Type, actor: Actor, timestamp: number) => void,
		actorId: Actor['id'],
		timestamp: number,
	) {
		const actor = this.actors.get(actorId)

		// Start the untargetable window, mirroring to invuln if configured to do so
		fn('untargetable', actor, timestamp)
		if (!this.skipMirroring.has(actorId)) {
			fn('invulnerable', actor, timestamp)
		}
	}

	private startTypeWindow = (type: Type, actor: Actor, timestamp: number) => {
		const windows = this.getActorWindows(actor)

		// If there's already an active window, piggyback on it
		const activeWindow = _.findLast(
			windows,
			window => window.active && window.type === type,
		)
		if (activeWindow != null) {
			return activeWindow
		}

		// Build & save the new window
		const window: Window = {
			active: true,
			type,
			start: timestamp,
			end: this.parser.pull.timestamp + this.parser.pull.duration,
		}
		windows.push(window)
		return window
	}

	private endTypeWindow = (type: Type, actor: Actor, timestamp: number) => {
		const windows = this.getActorWindows(actor)

		let activeWindow = _.findLast(
			windows,
			window => window.active && window.type === type
		)

		// TODO: The below was traditionally safe as we were precomputing, but this is effectively timewarping backwards. If i keep this as-is, i _must_ ensure that any lookups for an "all" value (if kept as a capability) only check for _known_ actors by this module, which will keep the below in sync (as it will technically only occur for newly-known actors).
		// i may be well-served by swapping logic here to only performing the backfill if no windows exist at all, rather than no active windows - might be safer.

		// == null means something became targetable, but never went untargetable
		// we can presume it has been untargetable since the start of the fight
		if (activeWindow == null) {
			// TODO: With the preemptive fill changes, this should probably be an error?
			activeWindow = this.startTypeWindow(type, actor, this.parser.pull.timestamp)
		}

		activeWindow.active = false
		activeWindow.end = Math.max(timestamp, activeWindow.start)
	}

	// TODO: Expose with options, ooor?
	private getActorWindows(actor: Actor) {
		let windows = this.windows.get(actor.id)
		if (windows == null) {
			windows = []
			this.windows.set(actor.id, windows)
		}
		return windows
	}

	private renderDebugTimelineData() {
		const startTime = this.parser.pull.timestamp

		const parentRow = this.timeline.addRow(new SimpleRow({
			label: 'Invuln2 Debug',
			order: -Infinity,
		}))

		for (const [actorId, windows] of this.windows) {
			const actor = this.actors.get(actorId)

			const actorRow = parentRow.addRow(new SimpleRow({
				label: `${actor.name} (id ${actor.id} kind ${actor.kind})`,
			}))

			// TODO: invuln/untarget

			for (const window of windows) {
				actorRow.addItem(new SimpleItem({
					start: window.start - startTime,
					end: window.end - startTime,
					content: <div style={{width: '100%', height: '100%', backgroundColor: '#faa'}}/>,
				}))
			}
		}
	}
}
