import {Event, Resource} from 'event'
import intersectingRanges from 'intersecting-ranges'
import _, {merge, mergeWith} from 'lodash'
import {P} from 'Object/_api'
import React from 'react'
import {Actor, ReportMetaKey, Team} from 'report'
import * as TB from 'ts-toolbelt'
import {isDefined} from 'utilities'
import {Analyser} from '../Analyser'
import {exists, filter, oneOf} from '../filter'
import {dependency} from '../Injectable'
import {Actors} from './Actors'
import {SimpleItem, SimpleRow, Timeline} from './Timeline'

export enum Check {
	/** Mark an actor as targetable when it is first targeted by an event. */
	FIRST_TARGETED,
	/** Check actor updates for changes to actor targetability. */
	TARGETABLE,
	/** Consider an actor as untargetable on death. */
	DEATH,
	/**
	 * Consider an actor as untargetable on hitting 1HP or being overkilled.
	 * Use for actors that do not die in a typical manner.
	 */
	OVERKILL,
}

const DEFAULT_CHECKS = [
	Check.FIRST_TARGETED,
	Check.TARGETABLE,
	Check.DEATH,
]

interface IncludedActorConfig {
	/**
	 * Checks to perform to determine targetability.
	 * Defaults to [FIRST_TARGETED, TARGETABLE, DEATH].
	 */
	checks?: Check[]

	/**
	 * Mirror 'untargetable' invuln windows into 'invulnerable' windows.
	 * Default `true`. Disable for actors that take damage while untargetable -
	 * you will need to add custom logic to add the invulnerable windows yourself.
	 */
	mirrorToInvuln?: boolean
}

type ActorConfig =
	& {kind: Record<ReportMetaKey, Actor['kind']>}
	& (
		| {exclude: true}
		| ({exclude?: false} & IncludedActorConfig)
	)

export type ActorsConfig = ActorConfig[]

const sharedActorConfig: ActorsConfig = [
	// Exclude unknown actors
	{kind: {legacyFflogs: 'unknown'}, exclude: true},
]

type Type = 'invulnerable' | 'untargetable'

interface Window {
	type: Type
	active: boolean
	start: number
	end: number
}

enum EdgeSide {
	START = 1,
	END = -1,
}

interface Edge {
	// TODO do we want type here, or should it be in the edge structure? - probably the latter
	// type: Type
	side: EdgeSide
	timestamp: number
	// TODO this needs to be something that correlates a start edge with its corresponding close edge
	// given we already will be splitting edges by at minimum actor, should be relatively simple?
	id: number
}

// TODO: Docs
export interface WindowFilter {
	start?: number
	end?: number
	type?: Type
	actorFilter?: (actor: Actor) => boolean
}

export class Invulnerability extends Analyser {
	static handle = 'invulnerability'
	static debug = true

	@dependency private actors!: Actors
	@dependency private timeline!: Timeline

	/**
	 * Array of configuration overrides. The default configuration should be fine
	 * for most actors - add an override if the derived invulnerability windows
	 * look wrong.
	 */
	protected actorConfig: ActorConfig[] = []

	private skipMirroring = new Set<Actor['id']>()
	private seenActors = new Set<Actor['id']>()
	private windows = new Map<Actor['id'], Window[]>()
	private edges = new Map<Actor['id'], Record<Type, Edge[]>>()

	// hmm
	private nextEdgeId = 0
	private getNextEdgeId = () => this.nextEdgeId++

	private defaultActorFilter = filter<Actor>().team(Team.FOE)

	getWindows({
		start = this.parser.pull.timestamp,
		end = this.parser.currentEpochTimestamp,
		type,
		actorFilter = this.defaultActorFilter,
	}: WindowFilter = {}) {
		// todo: both types
		console.time('naive')
		let mergedWindows: Window[] = [{
			type: 'untargetable',
			start,
			end,
			active: false, // TODO
		}]

		// const allWindows: Window[][] = []
		for (const actor of this.parser.pull.actors) {
			if (!actorFilter(actor)) { continue }

			const actorWindows = this.windows.get(actor.id)
			if (actorWindows == null) { continue }

			const filteredWindows = actorWindows.filter(window => true
				&& (window.end > start && window.start < end)
				&& (type == null || window.type === type)
			)
			// allWindows.push(filteredWindows)

			if (filteredWindows.length === 0) { continue }

			/// fshjkfhjafuhjasdfhjksdfhjklsdfghjklsdhjsdsdfghjl
			// this is fucking shit, but it works. improve.
			const currentWindows = mergedWindows
			mergedWindows = []
			for (const inputWindow of filteredWindows) {
				const intersectingWindows = currentWindows.filter(window =>
					window.end >= inputWindow.start &&
					window.start <= inputWindow.end &&
					window.type === inputWindow.type,
				)
				intersectingWindows.forEach(window => mergedWindows.push({
					type: window.type,
					start: Math.max(window.start, inputWindow.start),
					end: Math.min(window.end, inputWindow.end),
					active: false, // TODO
				}))
			}
		}
		console.timeEnd('naive')
		console.log('naive:', mergedWindows)

		console.time('marzullo')
		const allWindows: Array<[number, number]> = []
		for (const actor of this.parser.pull.actors) {
			if (!actorFilter(actor)) { continue }

			const actorWindows = this.windows.get(actor.id)
			if (actorWindows == null) { continue }

			// const filteredWindows = actorWindows.filter(window => true
			// 	&& (window.end > start && window.start < end)
			// 	&& (type == null || window.type === type)
			// )
			// allWindows.push(filteredWindows)
			for (const window of actorWindows) {
				if (
					!(window.end > start && window.start < end)
					|| !(type == null || window.type === type)
				) {
					continue
				}
				allWindows.push([window.start, window.end])
			}
		}

		const thing = intersectingRanges(allWindows)
		console.timeEnd('marzullo')
		console.log('marzullo:', thing)

		console.time('marzullo homebrew')
		const allWindowsHomebrew: Window[] = []
		let homebrewActorCount = 0
		for (const actor of this.parser.pull.actors) {
			if (!actorFilter(actor)) { continue }
			homebrewActorCount++

			// TODO: this returning null means they're always active, and hence
			// can noop the entire thing? not sure.
			const actorWindows = this.windows.get(actor.id)
			if (actorWindows == null) { continue }

			// const filteredWindows = actorWindows.filter(window => true
			// 	&& (window.end > start && window.start < end)
			// 	&& (type == null || window.type === type)
			// )
			// allWindows.push(filteredWindows)
			for (const window of actorWindows) {
				if (
					!(window.end > start && window.start < end)
					|| !(type == null || window.type === type)
				) {
					continue
				}
				allWindowsHomebrew.push(window)
			}
		}

		const thing2 = testMarzullo(allWindowsHomebrew, homebrewActorCount)
		console.timeEnd('marzullo homebrew')
		console.log('marzullo homebrew:', thing2)

		// TODO: TRY OUT THE HOMEBREW INLINE
		// all this shit will need to be refactored across a few methods
		// if a valid actor has no edges at all it MIGHT be active or inactive? we have no way to tell, right?
		console.time('marzullo inlined')
		// console.time('edge collection')
		// const actorEdges: Edge[][] = []
		const edges: CountedEdge[] = []
		let actorCount = 0
		for (const actor of this.parser.pull.actors) {
			if (!actorFilter(actor)) { continue }
			actorCount ++

			// TODO: handle types properly
			// if no data for the required stuff, noop
			// console.time('get actor edges')
			const typeEdges = this.edges.get(actor.id)?.untargetable
			if (typeEdges == null || typeEdges.length === 0) { continue }
			// console.timeEnd('get actor edges')

			// // console.time('get range indexes')
			// // get the indexes for relevant edges
			// const startIndex = typeEdges.findIndex(edge => edge.timestamp >= start)
			// const endIndex = _.findLastIndex(typeEdges, edge => edge.timestamp <= end)

			// // if all edges are outside the requested bounds, noop
			// if (startIndex === -1 || endIndex === -1) { continue }
			// // console.timeEnd('get range indexes')

			// // console.time('slice range')
			// // get the range
			// let rangeEdges = typeEdges.slice(startIndex, endIndex + 1)
			// TODO THIS ASSUMES THAT THE TYPE EDGES ARE SORTED. IS THAT SANE? I THINK SO, BUT CHECK
			// TODO i wonder if i can pull some more of the compute to this point? i don't _think_ so
			const rangeEdges: Edge[] = []
			let lastSide = EdgeSide.END
			for (const edge of typeEdges) {
				lastSide = edge.side
				if (edge.timestamp < start) { continue }
				if (edge.timestamp > end) { break }
				rangeEdges.push(edge)
			}

			// NOT SURE THAT THIS IS SANE??? what if the actor is invuln the entire duration
			// we only iterate the type edges until we collect the range, then immediately break
			// in that case, if we track the most recent edge side while iterating, after the loop,
			// that will be the most recent edge as of the end of the range
			// if length === 0, then that's the edge prior to the range, which, if it's a START, indicates
			// a full uptime window across the range.
			if (rangeEdges.length === 0) {
				if (lastSide === EdgeSide.START) {
					const id = this.getNextEdgeId()
					rangeEdges.push({
						id,
						side: EdgeSide.START,
						timestamp: start,
					}, {
						id,
						side: EdgeSide.END,
						timestamp: end,
					})
				} else {
					continue
				}
			}
			// console.timeEnd('slice range')

			// console.time('sanity check bounds')
			// make sure ranges specified by edges are sane around the cut
			if (rangeEdges[0].side === EdgeSide.END) {
				rangeEdges.unshift({
					id: rangeEdges[0].id,
					side: EdgeSide.START,
					timestamp: start,
				})
			}
			const lastEdge = rangeEdges[rangeEdges.length - 1]
			if (lastEdge.side === EdgeSide.START) {
				rangeEdges.push({
					id: lastEdge.id,
					side: EdgeSide.END,
					timestamp: end,
				})
			}
			// console.timeEnd('sanity check bounds')

			// aaaaand that's the range for this actor (per type?)
			// actorEdges.push(rangeEdges)
			// edges.concat
			Array.prototype.push.apply(edges, rangeEdges)
		}
		// console.timeEnd('edge collection')

		// TODO doc
		type CountedEdge = Edge & {count?: number};
		// const edges: CountedEdge[] = actorEdges.flat()
		// bleh
		edges.sort((a, b) => {
			const diff = a.timestamp - b.timestamp
			if (diff !== 0) { return diff }
			// this is clever as fuck but heavily relies on the counting system
			// doc enum.
			return a.side - b.side * (a.id === b.id ? -1 : 1)
		})

		const thing3: Array<[number, number]> = []

		// i don't think we need a max count here
		// we want an agreement with _all_ actors being invuln, not _the most_
		// TODO: given we know the required "max" count ahead of time due to actor count
		// might be able to completely skip the second loop below
		// might even be able to completely skip saving the count in, if we do the above
		let count = 0
		// for (const edge of edges) {
		// 	count += edge.side
		// 	edge.count = count
		// }
		for (let index = 0; index < edges.length; index++) {
			const edge = edges[index]
			count += edge.side

			if (count !== actorCount) { continue }

			thing3.push([
				edge.timestamp,
				edges[index + 1].timestamp,
			])
		}

		// TODO: check.... empty status? idfk

		// for (const [index, edge] of edges.entries()) {
		// 	if (edge.count !== actorCount) { continue }
		// 	thing3.push([
		// 		edge.timestamp,
		// 		edges[index + 1].timestamp,
		// 	])
		// }
		//

		console.timeEnd('marzullo inlined')
		console.log('marzullo inlined:', thing3)

		// return allWindows.flat()
		// return mergedWindows
		return thing2
	}

	initialise() {
		const reportSource = this.parser.newReport.meta.source

		// Flatten any subclass actor config to a map by the current report sources'
		// kind keys, for faster lookups later.
		const flatConfig = new Map([...sharedActorConfig, ...this.actorConfig].map(config => [
			config.kind[reportSource],
			config,
		]))

		// Group actors by the checks that should be performed on them.
		const actorChecks = new Map<Check, Array<Actor['id']>>()
		for (const actor of this.parser.pull.actors) {
			// Skip player-controlled actors and their pets
			// TODO: This is primarily for consistency with old systems. Consider if it's feasible to track PCs.
			if (this.isPlayerDerived(actor)) {
				continue
			}

			const config = flatConfig.get(actor.kind)

			// If the actor has been explicitly excluded, skip it entirely
			if (config != null && config.exclude) {
				continue
			}

			// Check if this actor should not be mirrored
			if (config?.mirrorToInvuln === false) {
				this.skipMirroring.add(actor.id)
			}

			// Add the actor to each of the check keys it is configured for
			const checks = config?.checks ?? DEFAULT_CHECKS
			for (const check of checks) {
				let foo = actorChecks.get(check)
				if (foo == null) {
					foo = []
					actorChecks.set(check, foo)
				}
				foo.push(actor.id)
			}
		}

		// Set up hooks for each check
		const addHooksFns: Record<Check, (actorIds: Array<Actor['id']>) => void> = {
			[Check.TARGETABLE]: this.addTargetableHooks,
			[Check.DEATH]: this.addDeathHooks,
			[Check.OVERKILL]: this.addOverkillHooks,
			[Check.FIRST_TARGETED]: this.addFirstTargetedHooks,
		}
		for (const [check, ids] of actorChecks) {
			addHooksFns[check](ids)
		}

		// TODO: LEGACY?
		// probably should just allow narrowing support ranges and drop legacy range

		this.debug(() => this.addEventHook('complete', this.renderDebugTimelineData))
	}

	private isPlayerDerived = (actor: Actor): boolean => false
		|| actor.playerControlled
		|| (actor.owner != null && this.isPlayerDerived(actor.owner))

	private addTargetableHooks = (actorIds: Array<Actor['id']>) => {
		// Preemptively start the first window at the beginning of the fight in case
		// the actor has been configured without first targeted
		for (const id of actorIds) {
			this.startWindow(id, this.parser.pull.timestamp)
		}

		this.addEventHook(
			filter<Event>()
				.type('actorUpdate')
				.actor(oneOf(actorIds))
				.targetable(exists),
			event => {
				// This should never be hit, but sanity check anyway
				if (event.targetable == null) { return }

				event.targetable
					? this.endWindow(event.actor, event.timestamp)
					: this.startWindow(event.actor, event.timestamp)
			}
		)
	}

	private addDeathHooks = (actorIds: Array<Actor['id']>) => {
		this.addEventHook(
			filter<Event>()
				.type('actorUpdate')
				.actor(oneOf(actorIds))
				.hp(filter<Resource>().current(0)),
			event => this.startWindow(event.actor, event.timestamp),
		)
	}

	private addOverkillHooks = (actorIds: Array<Actor['id']>) => {
		// Hook both overkill and an update to 1HP to ensure all cases are caught
		this.addEventHook(
			filter<Event>()
				.type('damage')
				.target(oneOf(actorIds))
				.overkill((v): v is number => v > 0),
			event => this.startWindow(event.target, event.timestamp),
		)
		this.addEventHook(
			filter<Event>()
				.type('actorUpdate')
				.actor(oneOf(actorIds))
				.hp(filter<Resource>().current(1)),
			event => this.startWindow(event.actor, event.timestamp),
		)
	}

	private addFirstTargetedHooks = (actorIds: Array<Actor['id']>) => {
		// Preemptively start the first window at the beginning of the fight
		for (const id of actorIds) {
			this.startWindow(id, this.parser.pull.timestamp)
		}

		// Exclude status updates, it's relatively common for player statuses to be mirrored to
		// untargetable actors, and we don't want that to crop up and cause issues.
		const ensureEventTypes = <T extends Event['type']>(types: T[]) => types
		const ignoredTypes = ensureEventTypes(['statusApply', 'statusRemove'])

		// This is basically an inverse oneOf
		// TODO: Look into genericising this. Will require some type hackery in filter, hence not doing right now.
		type PermittedTypes = TB.Union.Filter<
			Event['type'],
			(typeof ignoredTypes) extends Array<infer T> ? T : never
		>
		const ignoredTypesSet = new Set<Event['type']>(ignoredTypes)
		const matchType = (value: Event['type']): value is PermittedTypes => !ignoredTypesSet.has(value)

		// Track actors that have been seen so they may be skipped. If you're thinking
		// of copying this pattern, probably don't - preference adding temporary hooks
		// that you remove once they've done their job. This is only implemented with
		// a single hook here due to the majority of the 100+ mechanic actors common in
		// complex fights never removing their hook, and just chew unnessecary time.
		this.addEventHook(
			filter<Event>()
				.type(matchType)
				.target(oneOf(actorIds)),
			event => {
				// If the event is self-targeted, doesn't mean much - skip it
				// TODO: Look into moving this to the filter? Doing so will require access to event data in filter matchers, check lodash docs.
				// Also skip anything from targets we've already tracked a window for, we're only interested in the first event.
				if (
					this.seenActors.has(event.target)
					|| event.target === event.source
				) {
					return
				}

				this.endWindow(event.target, event.timestamp)
			}
		)
	}

	private startWindow = (actorId: Actor['id'], timestamp: number) =>
		this.manageConfigWindows(this.startType, actorId, timestamp)

	private endWindow(actorId: Actor['id'], timestamp: number) {
		this.manageConfigWindows(this.endType, actorId, timestamp)

		// It's not uncommon for some checks such as TARGETABLE to close a window before
		// the actor is first targeted - mark any actors we close a window on as seen
		// so as to ignore them for the FIRST_TARGETED check
		this.seenActors.add(actorId)
	}

	private manageConfigWindows(
		fn: (type: Type, actor: Actor, timestamp: number) => void,
		actorId: Actor['id'],
		timestamp: number,
	) {
		const actor = this.actors.get(actorId)

		// Start the untargetable window, mirroring to invuln if configured to do so
		fn('untargetable', actor, timestamp)
		if (!this.skipMirroring.has(actorId)) {
			fn('invulnerable', actor, timestamp)
		}
	}

	private startType = (type: Type, actor: Actor, timestamp: number) => {
		this.startTypeWindow(type, actor, timestamp)
		this.createStartEdge(type, actor, timestamp)
	}

	private startTypeWindow = (type: Type, actor: Actor, timestamp: number) => {
		const windows = this.getActorWindows(actor)

		// If there's already an active window, piggyback on it
		const activeWindow = _.findLast(
			windows,
			window => window.active && window.type === type,
		)
		if (activeWindow != null) {
			return
		}

		// Build & save the new window
		const window: Window = {
			active: true,
			type,
			start: timestamp,
			end: this.parser.pull.timestamp + this.parser.pull.duration,
		}
		windows.push(window)
	}

	private createStartEdge = (type: Type, actor: Actor, timestamp: number) => {
		const edges = this.getActorEdges(actor)

		const typeEdges = edges[type]
		const lastEdge = typeEdges[typeEdges.length - 1] as Edge | undefined

		// If the previous edge is a start, we can just piggyback on it.
		if (lastEdge != null && lastEdge.side === EdgeSide.START) {
			return
		}

		typeEdges.push({
			id: this.getNextEdgeId(),
			side: EdgeSide.START,
			timestamp,
			// type,
		})
	}

	private endType = (type: Type, actor: Actor, timestamp: number) => {
		this.endTypeWindow(type, actor, timestamp)
		this.createEndEdge(type, actor, timestamp)
	}

	private endTypeWindow = (type: Type, actor: Actor, timestamp: number) => {
		const windows = this.getActorWindows(actor)

		const activeWindow = _.findLast(
			windows,
			window => window.active && window.type === type
		)

		// If there's nothing open that we can close, noop. We can't sanely backfill in most cases,
		// as it may technically change historical information that other modules have already read.
		if (activeWindow == null) {
			// TODO: This practically only happens on dungeons. Maybe consider brokenlog?
			this.debug(`Actor ${actor.id} has no active ${type} window to end.`)
			return
		}

		activeWindow.active = false
		activeWindow.end = Math.max(timestamp, activeWindow.start)
	}

	private createEndEdge = (type: Type, actor: Actor, timestamp: number) => {
		const edges = this.getActorEdges(actor)

		const typeEdges = edges[type]
		const lastEdge = typeEdges[typeEdges.length - 1] as Edge | undefined

		// TODO: doc this fucking bullshit from the above when it isn't 3am
		if (lastEdge == null || lastEdge.side === EdgeSide.END) {
			this.debug(`shit: ${actor.id} ${type}`)
			return
		}

		typeEdges.push({
			id: lastEdge.id,
			side: EdgeSide.END,
			timestamp,
		})
	}

	// TODO: Expose with options, ooor?
	private getActorWindows(actor: Actor) {
		let windows = this.windows.get(actor.id)
		if (windows == null) {
			windows = []
			this.windows.set(actor.id, windows)
		}
		return windows
	}

	// HAHAHAHAH DO NOT EXPOSE THIS SHIT
	// maybe actually expose _something_ for edges to reduce algo time on recomputes like downtime
	private getActorEdges(actor: Actor) {
		let edges = this.edges.get(actor.id)
		if (edges == null) {
			edges = {
				invulnerable: [],
				untargetable: [],
			}
			this.edges.set(actor.id, edges)
		}
		return edges
	}

	private renderDebugTimelineData() {
		const startTime = this.parser.pull.timestamp
		const endTime = startTime + this.parser.pull.duration

		const parentRow = this.timeline.addRow(new SimpleRow({
			label: 'Invuln2 Debug',
			order: -Infinity,
		}))

		const kindRows = new Map<Actor['kind'], SimpleRow>()

		for (const [actorId, windows] of this.windows) {
			const actor = this.actors.get(actorId)

			let kindRow = kindRows.get(actor.kind)
			if (kindRow == null) {
				kindRow = parentRow.addRow(new SimpleRow({
					label: actor.kind,
				}))
				kindRows.set(actor.kind, kindRow)
			}

			const actorRow = kindRow.addRow(new SimpleRow({
				label: `${actor.name} (${actor.id})`,
				collapse: true,
			}))

			const invulnerableRow = actorRow.addRow(new SimpleRow({
				label: 'invulnerable',
			}))
			const untargetableRow = actorRow.addRow(new SimpleRow({
				label: 'untargetable',
			}))

			for (const window of windows) {
				// Windows that run the full length of the fight are meaningless to display
				if (window.start <= startTime && window.end >= endTime) {
					continue
				}

				const row = window.type === 'invulnerable'
					? invulnerableRow
					: untargetableRow
				row.addItem(new SimpleItem({
					start: window.start - startTime,
					end: window.end - startTime,
					content: <div style={{width: '100%', height: '100%', backgroundColor: '#faa8'}}/>,
				}))
			}
		}
	}
}

interface MarzulloPoint {
	value: number
	type: number // todo
	window: Window
	// yuck
	// index?: number
	count?: number
}

function testMarzullo(windows: Window[], expectedMax: number) {
	const START = 1
	const END = -1

	const points: MarzulloPoint[] = []

	for (const window of windows) {
		points.push({value: window.start, type: START, window})
		points.push({value: window.end, type: END, window})
	}

	// improve?
	points.sort((a, b) => {
		const diff = a.value - b.value
		if (diff !== 0) {
			return diff
		}
		// todo: work out whatever the fuck this is
		// relying on ref equality
		return a.type - b.type * (a.window === b.window ? -1 : 1)
	})

	const out: Window[] = []

	let count = 0
	// let maxCount = count
	// for (const point of points) {
	// 	count += point.type
	// 	// point.index = index
	// 	point.count = count

	// 	maxCount = Math.max(maxCount, point.count)
	// }
	for (let index = 0; index < points.length; index++) {
		const point = points[index]
		count += point.type

		if (count !== expectedMax) { continue }

		out.push({
			start: point.value,
			end: points[index + 1].value,
			type: 'untargetable',
			active: false,
		})
	}

	// todo: check empty status
	// console.log({maxCount, expectedMax})

	// for (const [index, point] of points.entries()) {
	// 	if (point.count !== maxCount) { continue }
	// 	out.push({
	// 		start: point.value,
	// 		end: points[index + 1].value,
	// 		type: 'untargetable',
	// 		active: false,
	// 	})
	// }

	return out
}
