import {Event, Events} from 'event'
import _ from 'lodash'
import React from 'react'
import {ReportMetaKey} from 'report'
import {Analyser} from '../Analyser'
import {exists, filter} from '../filter'
import {dependency} from '../Injectable'
import {Actors, Actor} from './Actors'
import {SimpleItem, SimpleRow, Timeline} from './Timeline'

// i'm tempted to say that the invuln config should be basically removed
// under what scenario is firsttab not a start?
// under what scenario is overkill not an end?
// If we assume we don't need config, then most of the old logic can become an adaption step, and this module can be pared down to effectively just tracking the invuln windows, and providing the capability for exclusion and mirroring?
// not sure it's really an adapter step tbh

interface IncludedActorConfig {
	/**
	 * Mirror 'untargetable' invuln windows into 'invulnerable' windows.
	 * Default `true`. Disable for actors that take damage while untargetable -
	 * you will need to add custom logic to add the invulnerable windows yourself.
	 */
	mirrorToInvuln?: boolean
}

type ActorConfig =
	& {kind: Record<ReportMetaKey, Actor['kind']>}
	& (
		| {exclude: true}
		| ({exclude: false} & IncludedActorConfig)
	)

export type ActorsConfig = ActorConfig[]

type Type = 'invulnerable' | 'untargetable'

interface Window {
	type: Type
	active: boolean
	start: number
	end: number
}

export class Invulnerability extends Analyser {
	static handle = 'invulnerability'
	static debug = true

	@dependency private actors!: Actors
	@dependency private timeline!: Timeline

	/** @todo docs */
	protected actorConfig: ActorConfig[] = []

	private flatConfig = new Map<Actor['kind'], ActorConfig>()
	private windows = new Map<Actor['id'], Window[]>()

	initialise() {
		// If there's any subclass actor config, flatten it to a map by the current
		// report sources' kind keys, for faster lookups later.
		if (this.actorConfig.length > 0) {
			const reportSource = this.parser.newReport.meta.source
			this.flatConfig = new Map(this.actorConfig.map(config => [
				config.kind[reportSource],
				config,
			]))
		}

		// TODO: LEGACY?
		// probably should just allow narrowing support ranges and drop legacy range

		this.addEventHook(
			filter<Event>().type('actorUpdate').targetable(exists),
			this.onTargetableChange,
		)
		// this.addEventHook('death', this.onDeath)
		// TODO: Look into generalising death for non-pc actors?
		this.addEventHook(
			{type: 'actorUpdate', hp: {current: 0}},
			this.onDeath,
		)

		this.debug(() => this.addEventHook('complete', this.renderDebugTimelineData))
	}

	private onTargetableChange(event: Events['actorUpdate']) {
		// This should never be hit, but sanity check anyway
		if (event.targetable == null) { return }

		event.targetable
			? this.endWindow(event.actor, event.timestamp)
			: this.startWindow(event.actor, event.timestamp)
	}

	private onDeath(event: Events['actorUpdate']) {
		this.startWindow(event.actor, event.timestamp)
	}

	private startWindow = (actorId: Actor['id'], timestamp: number) =>
		this.manageConfigWindows(this.startTypeWindow, actorId, timestamp)

	private endWindow = (actorId: Actor['id'], timestamp: number) =>
		this.manageConfigWindows(this.endTypeWindow, actorId, timestamp)

	private manageConfigWindows(
		fn: (type: Type, actor: Actor, timestamp: number) => void,
		actorId: Actor['id'],
		timestamp: number,
	) {
		// TODO: Should I exclude friendlies?
		// Get the actor data and the config for its kind
		const actor = this.actors.get(actorId)
		const config = this.flatConfig.get(actor.kind)

		// If the actor is explicitly excluded, we can noop
		if (config != null && config.exclude) {
			return
		}

		// Start the untargetable window, mirroring to invuln if configured to do so
		fn('untargetable', actor, timestamp)
		if (config?.mirrorToInvuln ?? true) {
			fn('invulnerable', actor, timestamp)
		}
	}

	private startTypeWindow = (type: Type, actor: Actor, timestamp: number) => {
		const windows = this.getActorWindows(actor)

		// If there's already an active window, piggyback on it
		const activeWindow = _.findLast(
			windows,
			window => window.active && window.type === type,
		)
		if (activeWindow != null) {
			return activeWindow
		}

		// Build & save the new window
		const window: Window = {
			active: true,
			type,
			start: timestamp,
			end: this.parser.pull.timestamp + this.parser.pull.duration,
		}
		windows.push(window)
		return window
	}

	private endTypeWindow = (type: Type, actor: Actor, timestamp: number) => {
		const windows = this.getActorWindows(actor)

		let activeWindow = _.findLast(
			windows,
			window => window.active && window.type === type
		)

		// TODO: The below was traditionally safe as we were precomputing, but this is effectively timewarping backwards. If i keep this as-is, i _must_ ensure that any lookups for an "all" value (if kept as a capability) only check for _known_ actors by this module, which will keep the below in sync (as it will technically only occur for newly-known actors).
		// i may be well-served by swapping logic here to only performing the backfill if no windows exist at all, rather than no active windows - might be safer.

		// == null means something became targetable, but never went untargetable
		// we can presume it has been untargetable since the start of the fight
		if (activeWindow == null) {
			activeWindow = this.startTypeWindow(type, actor, this.parser.pull.timestamp)
		}

		activeWindow.active = false
		activeWindow.end = timestamp
	}

	// TODO: Expose with options, ooor?
	private getActorWindows(actor: Actor) {
		let windows = this.windows.get(actor.id)
		if (windows == null) {
			windows = []
			this.windows.set(actor.id, windows)
		}
		return windows
	}

	private renderDebugTimelineData() {
		const startTime = this.parser.pull.timestamp

		const parentRow = this.timeline.addRow(new SimpleRow({
			label: 'Invuln2 Debug',
			order: -Infinity,
		}))

		for (const [actorId, windows] of this.windows) {
			const actor = this.actors.get(actorId)

			const actorRow = parentRow.addRow(new SimpleRow({
				label: `${actor.name} (${actor.kind})`,
			}))

			// TODO: invuln/untarget

			for (const window of windows) {
				actorRow.addItem(new SimpleItem({
					start: window.start - startTime,
					end: window.end - startTime,
					content: <div style={{width: '100%', height: '100%', backgroundColor: '#faa'}}/>,
				}))
			}
		}
	}
}
