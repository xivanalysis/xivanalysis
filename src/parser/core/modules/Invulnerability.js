import _ from 'lodash'
import Module from 'parser/core/Module'
import {Item} from 'parser/core/modules/Timeline'

// Ms of inactivity before an enemy is considered invuln
const MIN_INVULN_INACTIVITY = 5000

const ACTIVITY_EVENT_TYPES = ['begincast', 'damage', 'heal']

// Every log priior to this will use the old logic
const TARGETABLE_EVENT_IMPLEMENTATION_DATE = new Date('2019-08-05')

export default class Invulnerability extends Module {
	static handle = 'invuln'
	static dependencies = [
		'timeline',
		'additionalEvents', // eslint-disable-line @xivanalysis/no-unused-dependencies
	]

	_invulns = {}

	constructor(...args) {
		super(...args)
		this.addHook('complete', this._onComplete)
		this.addHook('targetabilityupdate', this._onTAU)
	}

	// -----
	// Normaliser
	// -----
	normalise(events) {
		const legacy = this.parser.parseDate < TARGETABLE_EVENT_IMPLEMENTATION_DATE.getTime()/1000

		// TODO(akk): Targetability invuln checking is currently broken. Feex. Check comments in _processTargetabileLogEvent.
		// eslint-disable-next-line no-constant-condition
		const processFn = (legacy || true)
			? this._processLegacyLogEvent.bind(this)
			: this._processTargetableLogEvent.bind(this)

		for (let i = 0; i < events.length; i++) {
			const event = events[i]
			processFn(event)
		}

		// TODO: Do i want to add events too or nah
		return events
	}

	/** Event processing logic for pre-targetability logs */
	_processLegacyLogEvent(event) {
		const target = event.targetID
		const playerId = this.parser.player.id

		if (
			// Make sure it's got all the info we care about, and we're tracking it
			!ACTIVITY_EVENT_TYPES.includes(event.type) ||
			!target ||
			!event.sourceID ||

			// we only care about casts and heals by the player onto something other than themselves
			(['begincast', 'heal'].includes(event.type) && (
				!event.sourceIsFriendly ||
				event.sourceID !== playerId ||
				event.sourceID === target
			)) ||

			// damage done to players happens all the time, ignore it
			(event.type === 'damage' && event.targetIsFriendly)
		) { return }

		if (!event.targetIsFriendly) {
			this._legacyCheckLastHits(target, event)
		}
		this._legacyCheckLastHits('all', event)
	}

	// Tracking all damage for full invuln, and non-tick damage for targetable
	// TODO: Work out how to track this better - currently relies on the person being parsed pressing buttons which isn't exactly the _best_ measure.
	_legacyLastHit = {}
	_legacyCheckLastHits(target, event) {
		const enemyLastHits = this._legacyLastHit[target] || {
			invulnerable: event.timestamp,
			untargetable: event.timestamp,
		}
		// Invuln
		this._legacyCheckForType(target, enemyLastHits, 'invulnerable', event)

		// Untargetable
		if (!event.tick) {
			this._legacyCheckForType(target, enemyLastHits, 'untargetable', event)
		}

		this._legacyLastHit[target] = enemyLastHits
	}

	_legacyCheckForType = (target, lastHits, type, event) => {
		const last = lastHits[type]
		const timeSince = event.timestamp - last

		if (timeSince > MIN_INVULN_INACTIVITY) {
			this.getInvulns(target).push({
				type: type,
				start: last,
				end: event.timestamp,
			})
		}

		lastHits[type] = event.timestamp
	}

	/** Event processing logic for logs after targetability was added */
	_processTargetableLogEvent(event) {
		const target = event.targetID

		/* TODO(akk): Notes
		- bit of duplication going on here, need to look into reducing
		- what's the expected handling when there's no last untargetable?
		- what's the story with deaths? are we getting no close event if someone is dead?
		- _need_ to work out what the story is going to be with invuln (vs untargetable).
			old new code used legacy invuln checks and TAU only for untarget, tempted to make
			untarget == invuln and allow override handling
			invuln statuses?
		*/

		if (event.type === 'targetabilityupdate') {
			if (!event.targetable) {
				this.getInvulns(target).push({
					type: 'untargetable',
					start: event.timestamp,
				})
			}

			if (event.targetable) {
				const lastUntargetableEvent = _.findLast(this.getInvulns(target), invuln => invuln.type === 'untargetable')
				// TODO(akk): this (and the one copied below) throws on undef
				if (lastUntargetableEvent.end != null) {
					//ohno
					throw new Error('closed a TAU that is already closed')
				}
				lastUntargetableEvent.end = event.timestamp
			}
		}

		if (event.type === 'death' && !event.targetIsFriendly) {
			const lastUntargetableEvent = _.findLast(this.getInvulns(target), invuln => invuln.type === 'untargetable')
			if (lastUntargetableEvent.end != null) {
				//ohno
				throw new Error('closed a TAU that is already closed')
			}
			lastUntargetableEvent.end = event.timestamp
		}
	}

	// -----
	// Event handlers
	// -----
	_onComplete() {
		const startTime = this.parser.fight.start_time

		// Add invulns to the timeline
		this.getInvulns().forEach(invuln => {
			this.timeline.addItem(new Item({
				type: 'background',
				start: invuln.start - startTime,
				end: invuln.end - startTime,
			}))
		})
	}

	// -----
	// Public API
	// -----
	isUntargetable = (
		targetId = 'all',
		time = this.parser.currentTimestamp,
	) => this._checkInvuln(targetId, time, 'untargetable')
	isInvulnerable = (
		targetId = 'all',
		time = this.parser.currentTimestamp,
	) => this._checkInvuln(targetId, time, 'invulnerable')

	getUntargetableUptime = (
		targetId = 'all',
		start = 0,
		end = this.parser.currentTimestamp,
	) => this._getInvulnUptime(targetId, start, end, 'untargetable')
	getInvulnerableUptime = (
		targetId = 'all',
		start = 0,
		end = this.parser.currentTimestamp,
	) => this._getInvulnUptime(targetId, start, end, 'invulnerable')

	getInvulns(targetId = 'all', start, end, type) {
		if (!this._invulns[targetId]) {
			this._invulns[targetId] = []
		}

		let invulns = this._invulns[targetId]

		// If filters have been set, run them
		// Only running _if_ set so unfiltered results can be pushed to
		if (start || end || type) {
			invulns = invulns.filter(invuln => {
				if (type && invuln.type !== type) { return false }
				if (start && invuln.end < start) { return false }
				if (end && invuln.start > end) { return false }
				return true
			})
		}

		return invulns
	}

	_getInvulnUptime(targetId, start, end, type) {
		return this.getInvulns(targetId, start, end, type)
			.reduce((uptime, invuln) => uptime + Math.min(invuln.end, end) - Math.max(invuln.start, start), 0)
	}

	_checkInvuln(targetId, time, type) {
		const filtered = this.getInvulns(targetId).filter(invuln =>
			invuln.type === type &&
			invuln.start <= time &&
			invuln.end >= time,
		)

		return !!filtered.length
	}
}
