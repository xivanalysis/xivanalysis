import Module from 'parser/core/Module'
import {Item} from 'parser/core/modules/Timeline'

// Ms of inactivity before an enemy is considered invuln
const MIN_INVULN_INACTIVITY = 5000

const ACTIVITY_EVENT_TYPES = ['begincast', 'damage', 'heal']

export default class Invulnerability extends Module {
	static handle = 'invuln'
	static dependencies = [
		'timeline',
	]

	_invulns = {}

	constructor(...args) {
		super(...args)
		this.addHook('complete', this._onComplete)
	}

	// -----
	// Normaliser
	// -----
	normalise(events) {
		// Tracking all damage for full invuln, and non-tick damage for targetable
		// TODO: Work out how to track this better - currently relies on the person being parsed pressing buttons which isn't exactly the _best_ measure.
		const lastHit = {}
		const playerId = this.parser.player.id

		const checkLastHits = (target, event) => {
			const enemyLastHits = lastHit[target] || {
				invulnerable: event.timestamp,
				untargetable: event.timestamp,
			}

			// Invuln
			checkForType(target, enemyLastHits, 'invulnerable', event)

			// Untargetable
			if (!event.tick) {
				checkForType(target, enemyLastHits, 'untargetable', event)
			}

			lastHit[target] = enemyLastHits
		}

		const checkForType = (target, lastHits, type, event) => {
			const last = lastHits[type]
			const timeSince = event.timestamp - last

			if (timeSince > MIN_INVULN_INACTIVITY) {
				this.getInvulns(target).push({
					type: type,
					start: last,
					end: event.timestamp,
				})
			}

			lastHits[type] = event.timestamp
		}

		for (let i = 0; i < events.length; i++) {
			const event = events[i]

			if (
				// Make sure it's got all the info we care about, and we're tracking it
				!ACTIVITY_EVENT_TYPES.includes(event.type) ||
				!event.targetID ||
				!event.sourceID ||
				// we only care about casts and heals by the player onto something other than themselves
				(['begincast', 'heal'].includes(event.type) && (
					!event.sourceIsFriendly ||
					event.sourceID !== playerId ||
					event.sourceID === event.targetID
				)) ||
				// damage done to players happens all the time, ignore it
				(event.type === 'damage' && event.targetIsFriendly)
			) { continue }

			if (!event.targetIsFriendly) {
				checkLastHits(event.targetID, event)
			}
			checkLastHits('all', event)
		}

		// TODO: Do i want to add events too or nah
		return events
	}

	// -----
	// Event handlers
	// -----
	_onComplete() {
		const startTime = this.parser.fight.start_time

		// Add invulns to the timeline
		this.getInvulns().forEach(invuln => {
			this.timeline.addItem(new Item({
				type: 'background',
				start: invuln.start - startTime,
				end: invuln.end - startTime,
			}))
		})
	}

	// -----
	// Public API
	// -----
	isUntargetable = (
		targetId = 'all',
		time = this.parser.currentTimestamp,
	) => this._checkInvuln(targetId, time, 'untargetable')
	isInvulnerable = (
		targetId = 'all',
		time = this.parser.currentTimestamp,
	) => this._checkInvuln(targetId, time, 'invulnerable')

	getUntargetableUptime = (
		targetId = 'all',
		start = 0,
		end = this.parser.currentTimestamp,
	) => this._getInvulnUptime(targetId, start, end, 'untargetable')
	getInvulnerableUptime = (
		targetId = 'all',
		start = 0,
		end = this.parser.currentTimestamp,
	) => this._getInvulnUptime(targetId, start, end, 'invulnerable')

	getInvulns(targetId = 'all', start, end, type) {
		if (!this._invulns[targetId]) {
			this._invulns[targetId] = []
		}

		let invulns = this._invulns[targetId]

		// If filters have been set, run them
		// Only running _if_ set so unfiltered results can be pushed to
		if (start || end || type) {
			invulns = invulns.filter(invuln => {
				if (type && invuln.type !== type) { return false }
				if (start && invuln.end < start) { return false }
				if (end && invuln.start > end) { return false }
				return true
			})
		}

		return invulns
	}

	_getInvulnUptime(targetId, start, end, type) {
		return this.getInvulns(targetId, start, end, type)
			.reduce((uptime, invuln) => uptime + Math.min(invuln.end, end) - Math.max(invuln.start, start), 0)
	}

	_checkInvuln(targetId, time, type) {
		const filtered = this.getInvulns(targetId).filter(invuln =>
			invuln.type === type &&
			invuln.start <= time &&
			invuln.end >= time,
		)

		return !!filtered.length
	}
}
